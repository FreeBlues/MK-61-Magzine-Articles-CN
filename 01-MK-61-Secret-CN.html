<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0">
<title>МК-61 可编程微型计算器的未记录功能</title>
<style>

.but {
	background-color:#CCCCCC;
	color:black;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 12px 0px 12px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_f {
	background-color:#F5E345;
	color:black;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 12px 0px 12px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_k {
	background-color:LightSkyBlue;
	color:white;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 12px 0px 12px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_cx {
	background-color:#F00505;
	color:white;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 8px 1px 8px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_b {
	background-color:black;
	color:white;

	font-weight:bold;
	font-family:monospace;

	padding:1px 8px 0px 8px;

	border:thin solid Gray;
	border-radius:3px;
	width:12px;
	white-space: nowrap;
}

.code  {
	background-color:#103810;
	color:#77FF77;

	font-family: monospace;
	font-weight:bold;
	padding:1px 2px 1px 2px;
	white-space: nowrap;
}

.reg {
	color:white;
	background-color:black;
	font-weight:bold;
}

.op_f {
	color:yellow;
	background-color:black;
}

.op_k {
	color:blue;
	background-color:#EEEEEE;
}

table {
	border-collapse: collapse;
}

table, th, td {
	border: 1px solid black;
}

.trcenter td, th {
	text-align: center;
}

.tdcenter {
	text-align: center;
}

.trblack td {
	background: #EEEEEE;
}

.trblack_black td {
	background: #BBBBBB;
}

.wall_color {
	background-color: #BBBBBB;
}

.align_right {
	text-align: right;
}

.li_change {
	list-style-type: none;
	text-indent: -1em;
}
.li_change::before {
	content: "*"
}

.li_add {
	list-style-type: none;
	text-indent: -1em;
}
.li_add::before {
	content: "+"
}

h2, h3, h4 {
    display: inline-block;
}

dt {
	margin-top: 1em;
}

.code_num {
	font-weight:bold;
	font-size:small;
}

page[size="A4"] {
      background: white;
      width: 21cm;
      height: 29.7cm;
      display: block;
      margin: 0 auto;
      margin-bottom: 0.5cm;
    }
    @media print {
      body,
      page[size="A4"] {
        margin: 0;
        box-shadow: 0;
      }
    }

</style>
</head>

<body>


	<h2>МК-61 可编程微型计算器的未记录功能</h2>




<details open>
	<summary><h3>目录</h3></summary>
<nav>
	<ul>
		<li><a href="#div_preface">前言</a></li>
		<li>
			<a href="#div_addr_space">程序地址空间</a>
			<ul><li><a href="#div_addr_space_using">实际应用</a></li></ul>
		</li>
		<li>
			<a href="#div_indirect_addr">间接寻址</a>
			<ul>
				<li><a href="#div_indirect_addr_gt1">
					大于或等于一的数字
				</a></li>
				<li><a href="#div_indirect_addr_lt1">
					正数但小于一
				</a></li>
				<li><a href="#div_indirect_addr_negative">
					负数
				</a></li>
				<li><a href="#div_indirect_addr_R0">
					R0...R3寄存器
				</a></li>
				<li><a href="#div_indirect_addr_R4">
					R4...R6寄存器
				</a></li>
				<li><a href="#div_indirect_addr_FL0">
					指令
					<span class="but_f">F</span><span class="op_f">FL0</span>&hellip;
					<span class="but_f">F</span><span class="op_f">FL3</span>
				</a></li>
				<li><a href="#div_indirect_addr_mantissa">
					尾数包含十六进制数字
				</a></li>
				<li><a href="#div_indirect_addr_exponent">
					指数包含十六进制数字
				</a></li>
				<li><a href="#div_indirect_addr_reg">
					值是寄存器编号，而不是地址
				</a></li>
				<li><a href="#div_indirect_addr_using">
					实际使用
				</a></li>
			</ul>
		</li>
		<li>
			<a href="#div_x2">神秘的X2寄存器</a>
			<ul>
				<li><a href="#div_x2_affect">
					影响X2的指令
				</a></li>
				<li><a href="#div_x2_point">
					指令<span class="but">.</span>（代码0A）
				</a></li>
				<li>
					<a href="#div_x2_exp">指令<span class="but">ВП</span>（代码0C）</a>
					<ul>
						<li><a href="#div_x2_exp_SR">
							恢复X2并舍弃第一位数字
						</a></li>
						<li><a href="#div_x2_exp_combine">
							恢复X2并用X中的数字替换第一位数字
						</a></li>
						<li><a href="#div_x2_exp_goto">
							<span class="but">ВП</span>紧跟在间接跳转之后
						</a></li>
						<li><a href="#div_x2_exp_plus">
							使用<span class="but">ВП</span>作为加法
						</a></li>
						<li><a href="#div_x2_exp_down">
							指令<span class="but">.</span>在
							<span class="but">ВП</span>之前“移动”X的捕获
						</a></li>
					</ul>
				</li>
				<li><a href="#div_x2_sum">总结</a></li>
			</ul>
		</li>
		<li>
			<a href="#div_hex">十六进制算术</a>
			<ul>
				<li><a href="#div_hex_h_plus_y">
					操作H <span class="but">+</span> Y（加法）
				</a></li>
				<li><a href="#div_hex_x_plus_h">
					操作X <span class="but">+</span> H（加法）
				</a></li>
				<li><a href="#div_hex_y_minus_h">
					操作Y <span class="but">-</span> H（减法）
				</a></li>
				<li><a href="#div_hex_h_minus_x">
					操作H <span class="but">-</span> X（减法）
				</a></li>
				<li><a href="#div_hex_h_mult_y">
					操作H <span class="but">&times;</span> Y（乘法）
				</a></li>
				<li><a href="#div_hex_x_mult_h">
					操作X <span class="but">&times;</span> H（乘法）
				</a></li>
				<li><a href="#div_hex_h_div_x">
					操作H <span class="but">&divide;</span> X（除法）
				</a></li>
				<li><a href="#div_hex_y_div_h">
					操作Y <span class="but">&divide;</span> H（除法）
				</a></li>
				<li><a href="#div_hex_func">
					对十六进制数的函数结果
				</a></li>
				<li><a href="#div_hex_using">
					实际应用
				</a></li>
			</ul>
		</li>
		<li>
			<a href="#div_zero_digit">用数字代替符号的数</a>
			<ul>
				<li><a href="#div_zero_digit_get">获取方式
				</a></li>
				<li><a href="#div_zero_digit_sign">数字的符号是什么？
				</a></li>
				<li><a href="#div_zero_digit_eval">这些数的算术运算
				</a></li>
				<li><a href="#div_zero_digit_sum">任意尾数和结论
				</a></li>
			</ul>
		</li>
		<li>
			<a href="#div_neg_zero_degree">具有负零次幂的数</a>
			<ul>
				<li><a href="#div_nzd_get">获取方式
				</a></li>
				<li><a href="#div_nzd_plus">加法和减法
				</a></li>
				<li><a href="#div_nzed_mult">乘法和除法
				</a></li>
				<li><a href="#div_nzd_func_F">“黄色”函数
				</a></li>
				<li><a href="#div_nzd_func_K">“蓝色”函数
				</a></li>
				<li><a href="#div_nzd_sum">总结
				</a></li>
			</ul>
		</li>
		<li><a href="#div_tricks">优化技巧</a></li>
		<li>
			<a href="#div_demo">演示程序</a>
			<ul>
				<li><a href="#div_demo_preface">程序界面描述
				</a></li>
			</ul>
			<ul>
				<li><a href="#div_demo_detail">程序分析
				</a></li>
			</ul>
			<ul>
				<li><a href="#div_demo_full">程序完整文本
				</a></li>
			</ul>
			<ul>
				<li><a href="#div_demo_tricks">
					程序中技巧和未记录特性的列表
				</a></li>
			</ul>
		</li>
		<li><a href="#div_command">附录. 所有指令</a></li>
		<li><a href="#div_glossary">术语列表</a></li>
		<li><a href="#translation">翻译说明</a></li>
	</ul>
</nav>
</details>

<hr>

<details id="div_preface" open>
	<summary><h3>前言</h3></summary>
	假设读者已经熟悉MK-61可编程微计算器（以下简称<a href="#div_glos_calculator">可编程计算器</a>）的操作，
	即<a href="https://www.wass.net/manuals/Elektronika%20MK-61.pdf" target="_blank">使用说明书</a>中所述的<em>已记录</em>功能。
	<p>
		<strong>使用未记录功能的目的</strong>通常是为了缩短程序长度（最“紧缺”的资源），较少的是为了释放额外的内存寄存器。
		<br>
		这些功能大多数只在程序模式下实现或使用。
		<br>
		有时这些功能被用来获取无法以常规方式创建的视频图像。
		<br>
		此外，了解未记录的功能有助于理解为什么有时程序的行为不完全如预期，或者完全不符合预期。
	</p>
	<p>
		本文档不涉及获取和研究<a href="#div_glos_super_num">超数</a>和<a href="#div_glos_F">空洞</a>，这些历史上已经由<a href="#div_glos_errors">错误学</a>研究过。
		但从所指的错误学中取用了<a href="#div_glos_err100">EГГOГa</a>和<a href="#div_glos_err200">3Г0ГГa</a>这些术语，并在某些地方用于获取非标准数字或结果。
	</p>
	<p>
		接下来，对于表示高位十六进制数字，使用标准表示法<strong>ABCDEF</strong>，同时在显示示例中使用可编程计算器的数字样式。
		<br>
		例如，数字<strong>8.FEDCBA9</strong>（作为数字8.0123456的倒置）将显示为
		<span class="code">&nbsp;8.&nbsp;EГCL-9&nbsp;&nbsp;&nbsp;</span>。
		<br>
		需要理解的是，在可编程计算器中，只有十六进制数字，而不是数字，即可编程计算器仍然将每一位视为十进制。
		也就是说，通常等于255的FF将被解释为F &times; 10 + F，即150 + 15 = 165。
	</p>
	<p>
		由于可编程计算器可以使用<a href="#div_glos_unnormalize">非规范化数字</a>，因此区分这一点很重要，例如：非规范化的0.005^-03是
		<span class="code">&nbsp;0.005&nbsp;&nbsp;&nbsp;-03</span>，
		而规范化的则是5.^-06
		<span class="code">&nbsp;5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-06</span>。
		文本中将非规范化数字记录为带有前导零的形式。
	</p>
</details>

<hr>

<details id="div_addr_space" open>
	<summary><h3>程序地址空间</h3></summary>
	程序地址的文档值是105个单元。
	实际上情况要复杂一些。
	提醒一下，单元地址只使用两个数字，因此对于超过99的地址使用十六进制数字。
	<p></p>
 


<table class="trcenter">
	<tr><th>形式地址</th><th>实际地址</th><th>附加地址</th></tr>
 
	<tr><td>00</td><td>00</td><td></td></tr>
			<tr><td>01</td><td>01</td><td></td></tr>
			<tr><td colspan=3>&hellip;</tr>
			<tr><td>99</td><td>99</td><td></td></tr>
			<tr><td>A0</td><td>A0</td><td></td></tr>
			<tr><td>A1</td><td>A1</td><td></td></tr>
			<tr><td>A2</td><td>A2</td><td></td></tr>
			<tr><td>A3</td><td>A3</td><td></td></tr>
			<tr><td>A4</td><td>A4</td><td></td></tr>
			<tr><td colspan=3></td></tr>
			<tr><td>A5</td><td>00</td><td></td></tr>
			<tr><td>A6</td><td>01</td><td></td></tr>
			<tr><td>A7</td><td>02</td><td></td></tr>
			<tr><td>A8</td><td>03</td><td></td></tr>
			<tr><td>A9</td><td>04</td><td></td></tr>
			<tr><td>B0</td><td>05</td><td></td></tr>
			<tr><td>B1</td><td>06</td><td></td></tr>
			<tr><td colspan=3></td></tr>
			<tr><td>B2</td><td>00</td><td></td></tr>
			<tr><td>B3</td><td>01</td><td></td></tr>
			<tr><td>B4</td><td>02</td><td></td></tr>
			<tr><td>B5</td><td>03</td><td></td></tr>
			<tr><td>B6</td><td>04</td><td></td></tr>
			<tr><td>B7</td><td>05</td><td></td></tr>
			<tr><td>B8</td><td>06</td><td></td></tr>
			<tr><td>B9</td><td>07</td><td></td></tr>
			<tr class="trblack"><td>C0</td><td>08</td><td></td></tr>
			<tr class="trblack"><td>C1</td><td>09</td><td></td></tr>
			<tr class="trblack"><td>C2</td><td>10</td><td></td></tr>
			<tr class="trblack"><td>C3</td><td>11</td><td></td></tr>
			<tr class="trblack"><td>C4</td><td>12</td><td></td></tr>
			<tr class="trblack"><td>C5</td><td>13</td><td></td></tr>
			<tr class="trblack"><td>C6</td><td>14</td><td></td></tr>
			<tr class="trblack"><td>C7</td><td>15</td><td></td></tr>
			<tr class="trblack"><td>C8</td><td>16</td><td></td></tr>
			<tr class="trblack"><td>C9</td><td>17</td><td></td></tr>
			<tr class="trblack"><td>D0</td><td>18</td><td></td></tr>
			<tr class="trblack"><td>D1</td><td>19</td><td></td></tr>
			<tr class="trblack"><td>D2</td><td>20</td><td></td></tr>
			<tr class="trblack"><td>D3</td><td>21</td><td></td></tr>
			<tr class="trblack"><td>D4</td><td>22</td><td></td></tr>
			<tr class="trblack"><td>D5</td><td>23</td><td></td></tr>
			<tr class="trblack"><td>D6</td><td>24</td><td></td></tr>
			<tr class="trblack"><td>D7</td><td>25</td><td></td></tr>
			<tr class="trblack"><td>D8</td><td>26</td><td></td></tr>
			<tr class="trblack"><td>D9</td><td>27</td><td></td></tr>
			<tr class="trblack"><td>E0</td><td>28</td><td></td></tr>
			<tr class="trblack"><td>E1</td><td>29</td><td></td></tr>
			<tr class="trblack"><td>E2</td><td>30</td><td></td></tr>
			<tr class="trblack"><td>E3</td><td>31</td><td></td></tr>
			<tr class="trblack"><td>E4</td><td>32</td><td></td></tr>
			<tr class="trblack"><td>E5</td><td>33</td><td></td></tr>
			<tr class="trblack"><td>E6</td><td>34</td><td></td></tr>
			<tr class="trblack"><td>E7</td><td>35</td><td></td></tr>
			<tr class="trblack"><td>E8</td><td>36</td><td></td></tr>
			<tr class="trblack"><td>E9</td><td>37</td><td></td></tr>
			<tr class="trblack"><td>F0</td><td>38</td><td></td></tr>
			<tr class="trblack"><td>F1</td><td>39</td><td></td></tr>
			<tr class="trblack"><td>F2</td><td>40</td><td></td></tr>
			<tr class="trblack"><td>F3</td><td>41</td><td></td></tr>
			<tr class="trblack"><td>F4</td><td>42</td><td></td></tr>
			<tr class="trblack"><td>F5</td><td>43</td><td></td></tr>
			<tr class="trblack"><td>F6</td><td>44</td><td></td></tr>
			<tr class="trblack"><td>F7</td><td>45</td><td></td></tr>
			<tr class="trblack"><td>F8</td><td>46</td><td></td></tr>
			<tr class="trblack"><td>F9</td><td>47</td><td></td></tr>
			<tr><td colspan=3></td></tr>
			<tr class="trblack_black"><td>FA</td><td>48</td><td>01</td></tr>
			<tr class="trblack_black"><td>FB</td><td>49</td><td>02</td></tr>
			<tr class="trblack_black"><td>FC</td><td>50</td><td>03</td></tr>
			<tr class="trblack_black"><td>FD</td><td>51</td><td>04</td></tr>
			<tr class="trblack_black"><td>FE</td><td>52</td><td>05</td></tr>
			<tr class="trblack_black"><td>FF</td><td>53</td><td>06</td></tr>
		</table>


<p>
	第一个次要分支（返回到零地址）较短 &ndash;
	地址A5&hellip;B1，它们显示为地址00&hellip;06。
</p>
<p>
	第二个次要分支较长 &ndash; 地址B2&hellip;F9，它们
	显示为地址00&hellip;37。
	其中地址C0&hellip;F9是<a href="#div_glos_shadow">暗的</a>，
	例如，如果执行
	<span class="but_b">БП</span>&ensp;
	<span class="but">10</span>&ensp;
	<span class="but_f">F</span><span class="op_f">ПРГ</span>，并在地址10&hellip;12输入命令
	<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
	<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
	<span class="but_k">К</span><span class="op_k">НОП</span>，
	那么我们将看到
	<span class="code">&nbsp;54&nbsp;54&nbsp;54&nbsp;13</span>。
	但如果然后转到地址C5
	（<span class="but_f">F</span><span class="op_f">АВТ</span>&ensp;
	<span class="but_b">БП</span>&ensp;
	<span class="but">C5</span>&ensp;
	<span class="but_f">F</span><span class="op_f">ПРГ</span>），那么我们将得到
	<span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C5</span>，
	尽管实际上这将是相同的程序代码。
</p>
<p>
	只能间接跳转到<strong>超级暗的</strong>地址FA&hellip;FF，
	因为直接输入以数字F开头的地址是不可能的。
	不过，一些在手动模式下描述的非标准命令序列，在<a href="#div_command">附录</a>的最后部分，
	允许插入以F开头的命令。此外，对于MK-52的所有者来说，有一个内置的方法
	从单独的模块中做“or”命令，以获得以数字F开头的代码。
	<br>
	所以，超级暗地址的特点是，跳转到它之后只执行一个(!)命令，然后跳转到
	最后一列中指定的附加地址。
</p>
<p>
	如果在跳转地址中的第二个数字也是十六进制的，那么如前言所述，它就原样相加（E = 14等）。
	因此，跳转到地址9F（90 + 15）或A5（100 + 5）或
	AC（100 + 12 = 110 + 2 = B2）或B2，将
	等同于跳转到地址00，只是命令的顺序将不同。
</p>
<p>
	如果命令本身是双重的，即带有跳转地址（例如，
	<span class="but_b">БП</span>，
	<span class="but_f">F</span><span class="op_f">x&lt;0</span>，
	<span class="but_f">F</span><span class="op_f">L1</span>），
	并且此时地址发生“断裂”，那么命令的第二部分
	（跳转地址）将从新位置读取。也就是说，如果地址06
	有一个命令<span class="but_b">БП</span>，
	那么在正常流程中跳转地址将是07，但如果
	像在地址B1那样来到这里，那么跳转地址将是00。
</p>

<details id="div_addr_space_using" open>
	<summary><h4>实际应用</h4></summary>
	<ul>
		<li>
			根据初始地址安排控制执行流程的命令的位置，在程序的末尾（或中间，取决于
			次要分支）不使用它们（自动跳转到主分支的开始）
			以减少程序长度。通常这个角色由
			<span class="but_b">В/О</span>扮演，但也可以是条件跳转，
			<span class="but_b">С/П</span>等。
		</li>
		<li>
			使用不同的值通过同一个地址进行实际跳转（如上所述）。非标准分支。
		</li>
		<li>
			根据形式地址改变双重命令的跳转地址（如上所述）。这也是非标准分支。
		</齐li>
	</ul>
</details>

</details>

<hr>
 
<details id="div_indirect_addr_gt1" open>
	<summary><h4>
		变体
		+M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub>^+P<sub>1</sub>P<sub>2</sub>
		，即数字大于或等于一（1.0 &les; N）
	</h4></summary>
在这种情况下，数字左侧补上7 &minus; P<sub>2</sub>个零
（只有当结果非负时），将尾数的其余部分“挤出”到右边。数字的指数（以规范化形式）在此过程中
不变。
<br>
为了直观起见，我们提供了一个基于简单尾数的转换表，以便看到哪些位移到了哪里：
<p></p>
<table>
	<tr>
		<th>之前</th>
		<th>7-P<sub>2</sub>
		<th>零</th>
		<th>之后</th>
		<th>相同</th>
	</tr>
	<tr>
		<td class="code">&nbsp;1.2345678&nbsp;&nbsp;&nbsp;</td>
		<td class="tdcenter">7</td>
		<td class="tdcenter">7</td>
		<td class="code">&nbsp;00000001.&nbsp;&nbsp;&nbsp;</td>
		<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
	</tr>
	<tr>
					<td class="code">&nbsp;1.2345678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">7</td>
					<td class="tdcenter">7</td>
					<td class="code">&nbsp;00000001.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;12.345678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">6</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;00000012.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;123.45678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">5</td>
					<td class="tdcenter">5</td>
					<td class="code">&nbsp;00000123.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1234.5678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">4</td>
					<td class="tdcenter">4</td>
					<td class="code">&nbsp;00001234.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;1234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;12345.678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">3</td>
					<td class="tdcenter">3</td>
					<td class="code">&nbsp;00012345.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;12345.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;123456.78&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">2</td>
					<td class="tdcenter">2</td>
					<td class="code">&nbsp;00123456.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;123456.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1234567.8&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">1</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;01234567.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;1234567.&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;12345678.&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">0</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;12345678.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;12345678.&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;08</td>
					<td class="tdcenter">-1</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;08</td>
					<td class="code">&nbsp;1.2345678&nbsp;08</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;09</td>
					<td class="tdcenter">-2</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;09</td>
					<td class="code">&nbsp;1.2345678&nbsp;09</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;10</td>
					<td class="tdcenter">7</td>
					<td class="tdcenter">7</td>
					<td class="code">&nbsp;0.0000001&nbsp;17</td>
					<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;11</td>
					<td class="tdcenter">6</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;0.0000012&nbsp;17</td>
					<td class="code">&nbsp;1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11</td>
				</tr>
				<tr>
					<td colspan="5">&hellip;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;96</td>
					<td class="tdcenter">1</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;0.1234567&nbsp;97</td>
					<td class="code">&nbsp;1.234567&nbsp;&nbsp;96</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;97</td>
					<td class="tdcenter">0</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;97</td>
					<td class="code">&nbsp;1.2345678&nbsp;97</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;98</td>
					<td class="tdcenter">-1</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;98</td>
					<td class="code">&nbsp;1.2345678&nbsp;98</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;99</td>
					<td class="tdcenter">-2</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;99</td>
					<td class="code">&nbsp;1.2345678&nbsp;99</td>
				</tr>
	
</table>


<p>
				顺便说一下，这条规则表明，对于普通的整数，其顺序（从零开始）与数字位数减一相匹配时，左边会补上足够的零，使其总共有8位数字。
				也就是说，数字保持不变，这与文档描述相符。
				如果除了整数部分还有小数部分，同样的规则表明，补上的零会完全“挤出”小数部分，这在程序中经常被用来简化：不需要去除小数部分，因为间接寻址会自动去除它。
			</p>
		</details>


	<details id="div_indirect_addr_lt1" open>
		<summary><h4>
			变体
			+M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub>^-P<sub>1</sub>P<sub>2</sub>
			，即数字本身是非负的，但小于1（0.0 ≤ N < 1.0）
		</h4></summary>
		在这种情况下，补上的零的数量是这样确定的。计算1P<sub>2</sub> - 3，如果结果的最后一位数字 < 8，那么这就决定了零的数量。否则不做任何事情。
		<p></p>
		<table>
			<tr>
				<th>之前</th>
				<th>1P<sub>2</sub>&minus;3</th>
				<th>零的数量</th>
				<th>之后</th>
				<th>同上</th>
			</tr>
<tr>
					<td class="code">&nbsp;1.2345678-01</td>
					<td class="tdcenter">8</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-01</td>
					<td class="code">&nbsp;1.2345678-01</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-02</td>
					<td class="tdcenter">9</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-02</td>
					<td class="code">&nbsp;1.2345678-02</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-03</td>
					<td class="tdcenter">10</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-03</td>
					<td class="code">&nbsp;1.2345678-03</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-04</td>
					<td class="tdcenter">11</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;0.1234567-03</td>
					<td class="code">&nbsp;1.234567&nbsp;-04</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-05</td>
					<td class="tdcenter">12</td>
					<td class="tdcenter">2</td>
					<td class="code">&nbsp;0.0123456-03</td>
					<td class="code">&nbsp;1.23456&nbsp;&nbsp;-05</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-06</td>
					<td class="tdcenter">13</td>
					<td class="tdcenter">3</td>
					<td class="code">&nbsp;0.0012345-03</td>
					<td class="code">&nbsp;1.2345&nbsp;&nbsp;&nbsp;-06</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-07</td>
					<td class="tdcenter">14</td>
					<td class="tdcenter">4</td>
					<td class="code">&nbsp;0.0001234-03</td>
					<td class="code">&nbsp;1.234&nbsp;&nbsp;&nbsp;&nbsp;-07</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-08</td>
					<td class="tdcenter">15</td>
					<td class="tdcenter">5</td>
					<td class="code">&nbsp;0.0000123-03</td>
					<td class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-09</td>
					<td class="tdcenter">16</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;0.0000012-03</td>
					<td class="code">&nbsp;1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-09</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-10</td>
					<td class="tdcenter">7</td>
					<td class="tdcenter">7</td>
					<td class="code">&nbsp;0.0000001-03</td>
					<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-10</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-11</td>
					<td class="tdcenter">8</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-11</td>
					<td class="code">&nbsp;1.2345678-11</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-12</td>
					<td class="tdcenter">9</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-12</td>
					<td class="code">&nbsp;1.2345678-12</td>
				</tr>
				<tr>
					<td colspan="5">&hellip;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-23</td>
					<td class="tdcenter">10</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-23</td>
					<td class="code">&nbsp;1.2345678-23</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-24</td>
					<td class="tdcenter">11</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;0.1234567-23</td>
					<td class="code">&nbsp;1.234567&nbsp;-24</td>
				</tr>
				<tr>
					<td colspan="5">&hellip;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-99</td>
					<td class="tdcenter">16</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;0.0000012-93</td>
					<td class="code">&nbsp;1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-99</td>
				</tr>
			</table>
		</details>


		例子：
		<span class="code">-123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
		将变为
		<span class="code">-99999123.&nbsp;&nbsp;&nbsp;</span>，
		即跳转地址 = 23。
		

		例子：
		<span class="code">-1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>
		不会改变，即跳转地址将等于零。
		

		例子：
		<span class="code">-1.2345678-08</span>
		将变为
		<span class="code">-9.9999123-03</span>，即跳转地址 = 23。
		<p>
			这里需要做一个<strong>备注</strong>。有一个假设，即九不是随机的，而是等于10 - 1，其中10是负号（如同十六进制数字A）。
			为了验证这个假设，我们可以取一个用数字代替符号的数（参见<a href="#div_zero_digit">
				代替符号的数字
			</a>以获取算法）。
			例如<span class="code">2E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
			其中二代替了符号。在进行间接寻址时：
			<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
			<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">9</span>。
			二减少一变成
			<span class="code">21111111E.&nbsp;&nbsp;&nbsp;</span>。
			对于其他数字也是类似的，例如，对于
			<span class="code">9E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
			（在<span class="but">/-/</span>之后）执行间接寻址，我们将得到
			<span class="code">98888888E.&nbsp;&nbsp;&nbsp;</span>。
		</p>



		<p>
			现在让我们考虑一种情况，即寄存器本身的值也会如文档中描述的那样改变。请注意，变化并不是在任何间接寻址时都会发生，而只是在计算跳转地址的值时才会发生。例如，在条件操作符
			<span class="but_k">К</span><span class="op_f">x&lt;0</span><span
			class="but">4</span>中，只有当x&ges;0时，即当需要计算跳转地址时，寄存器R4才会被修改。
		</p>
	</details>


<details id="div_indirect_addr_R0" open>
			<summary><h4>寄存器 R0...R3</h4></summary>
			对于它们，转换后的值
			会先减去1，不考虑顺序和符号。
			只计算（但包括所有）尾数的数字。如果
			原来是零，则转换为-99999999。
			由于不考虑符号，结果是对于负数
			数字会增加（在算术意义上），
			而不是减少。例子：
			<p>
				<span class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
				表示为1.23^02，将变为0.0000123^+07，
				然后减少到0.000012<strong>2</strong>^+07并转换为
				<span class="code">&nbsp;00000122.&nbsp;&nbsp;&nbsp;</span>，
				即跳转地址 = 22。
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>，
				表示为1.2300000^-02，将减少到
				1.2<strong>299999</strong>^-02
				并转换为<span class="code">&nbsp;1.2299999-02</span>，
				即跳转地址 = 99。
				<br>
				<span class="code">-123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
				表示为-1.23^+02，转换为-9.9999123^+07，
				然后减少到-9.999912<strong>2</strong>^+07，转换为
				<span class="code">-9.9999122.&nbsp;&nbsp;&nbsp;</span>，
				即跳转地址 = 22。
				<br>
				<span class="code">-1.2345678-08</span>，转换为-9.9999123^-03，
				然后减少到-9.999912<strong>2</strong>^-03，转换为
				<span class="code">-9.9999122-03</span>，即跳转地址 = 22。
			</p>
			<p>
				请注意，在减少尾数到零时，数字的顺序
				保持不变。例如，如果原来是1.^-20，那么转换后将是0.0000001^-13，减少后将是
				0.000000<strong>0</strong>^-13，即
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-13</span>。
				的确，这样的零，除了外观不同，操作上与
				普通零没有区别。但结合其他
				未记录的功能，这些功能可能会结合
				来自不同数字的尾数和顺序
				（见<a href="#div_x2_exp_combine">神秘的寄存器X2</a>）
				这可能会有用。
				同样地，从1.^90得到的是
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;97</span>。
			</p>
		</details>

		<details id="div_indirect_addr_R4" open>
			<summary><h4>寄存器 R4...R6</h4></summary>
			对于它们，转换后的值
			会先增加1，同样不考虑顺序和符号。
			如果原来是-99999999（全是九），则转换为零。
			类比负数的备注，数字
			+99999999（全是九）转换为数字，其中符号位被数字取代：
			<span class="code">200000000.&nbsp;&nbsp;&nbsp;</span>（符号位上是2）。它的行为就像普通的零。例子：
			<p>
				<span class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
				表示为1.23^+02，将变为0.0000123^+07，然后
				增加到0.000012<strong>4</strong>^+07并转换为
				<span class="code">&nbsp;00000124.&nbsp;&nbsp;&nbsp;</span>，即
				跳转地址 = 24。
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>，
				表示为1.2300000^-02，将增加到
				1.230000<strong>1</strong>^+02并转换为
				<span class="code">&nbsp;1.2300001-02</span>，即跳转地址 = 01。
				<br>
				<span class="code">-123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
				表示为-1.23^+02，转换为-9.9999123^+07，
				然后增加到-9.999912<strong>4</strong>^+07，转换为
				<span class="code">-99999124.&nbsp;&nbsp;&nbsp;</span>，
				即跳转地址 = 24。
				<br>
				<span class="code">-1.2345678-08</span>，转换为-9.9999123^-03，
				然后增加到-9.999912<strong>4</strong>^-03，转换为
				<span class="code">-9.9999124-03</span>，即跳转地址 = 24。
			</p>
		</details>


<details id="div_indirect_addr_FL0" open>
			<summary><h4>
				命令 <span class="but_f">F</span><span class="op_f">FL0</span>&hellip;
				<span class="but_f">F</span><span class="op_f">FL3</span>
			</h4></summary>
			对于它们，适用与
			寄存器 R0...R3相同的规则，只是在减少之前检查
			得到的数字是否等于一（同样不考虑符号和顺序）。
			如果得到的是一，循环将结束，
			并且转换后的值不会被写回寄存器。例子：
			<p>
				<span class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
				表示为1.23^+02，将变为0.0000123^+07，
				然后减少到0.000012<strong>2</strong>^+07并转换为
				<span class="code">&nbsp;00000122.&nbsp;&nbsp;&nbsp;</span>，
				循环继续。
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>，
				表示为1.2300000^-02，将减少到1.2299999^-02
				并转换为<span class="code">&nbsp;1.2299999-02</span>，
				循环继续。
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
				转换为00000001，等于一 &ndash; 循环将结束，原始数字不会改变，
				即保持为<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-10</span>，
				表示为1.23^-10，转换为0.0000001^-03，
				等于一 &ndash; 循环将结束，原始数字不会改变。
			</p>
			<p>
				可以通过寄存器 R7...Re来“检查是否为一”。
				如果在执行
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">R</span>
				后在屏幕上尾数显示为00000001（并且某处有点），则意味着
				循环将在原始数字上中断。
			</p>
		</details>

		<details id="div_indirect_addr_mantissa" open>
			<summary><h4>尾数包含十六进制数字</h4></summary>
			在这种情况下，十六进制数字的<strong>减少</strong>
			进行到9，然后像往常一样。减少到0以下时，借位
			（减少前一个数字，可能也是十六进制数字），
			此时当前数字将不是F，而是像往常一样为9。
			<p>
				跳转同样会到十六进制地址，但这一点我们已经
				熟悉（见<a href="#div_addr_space">程序地址空间</a>）。
			</p>
			<p>
				不幸的是，如果是<strong>增加</strong>，那么带有
				十六进制数字的数字会先进行
				<a href="#div_glos_normalization">规范化</a>（从右向左，
				意义如术语列表中所述）：
				字母被视为两位数，多余的个位数进位到
				高位。例如，将数字9AE和1相加将是这样：E = 14，
				所以最后一位数字4 + 1 = 5并且心里记着1；
				然后A = 10 + 1心里，将是11，即1和1心里；
				接下来9 + 1 = 10。总共1015。这意味着通过R4...R6的间接寻址
				总是会去除数字中的十六进制数字。
				同时，数字的非标准符号（见负数变体中的备注）
				保持不变。
			</p>
		</details>


<details id="div_indirect_addr_exponent" open>
			<summary><h4>指数包含十六进制数字</h4></summary>
			实际上，如果不涉及Egogology，我们只能使用运算符
			<span class="but_f">F</span><span class="op_f">10ˣ</span>得到1.^±HH。
			<p>
				对于形式为1.^+0H（一个数字）的数字，不进行任何转换，
				这意味着跳转地址始终为零。
				如果是增加或减少（通过选择寄存器），
				则尾数根据上述规则增加或减少，
				而符号和指数不变。
				例子：如果在R0寄存器中写入
				<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0E</span>
				并执行
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span>，
				那么结果将是尾数100000000减少到09999999，
				即<span class="code">&nbsp;0.9999999&nbsp;0E</span>。
			</p>
				对于形式为1.^-0H（也是一个数字）的数字，同样不进行任何转换。唯一我想强调的是这种数字的值。在这种情况下，指数被认为是
				模16的，即-E，这是-14或2。结果是
				1.^-0E = 100, 1.^-0D = 1000, 1.^-0C = 10000, 1.^-0B = 100000，而...
				1.^-0A是不可能的（将直接变为1.^-10，并保持不变）。
			<p>
			</p>
			<p>
				对于两位数的指数，情况更复杂。以1.^+B0为例
				（<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L0</span>）。
				顺便说一下，1.^+AA将自动转换为1.^+B0，
				就像1.^+0A将自动转换为1.^+10一样
				（不知为何特别不喜欢A，对于其他数字没有发现这种情况，
				尽管在这里也可以欺骗，如果输入1^.-LL
				然后按<span class="but">ВП</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">5</span>）。
				所以，实际上这个数字等于1.^+110。如你所见，指数的符号被数字取代，但对于ПМК来说，这也等同于符号，
				因此将应用负指数的规则，即在左边补上7（= 10 - 3且小于8）个零，这将导致0.0000001^117。
				即作为跳转地址将是01，但从寄存器中最好不要提取这个数字，因为它将成为超级数字，在屏幕上显示为ЕГГ0Г。
			</p>
			<p>
				如果两位数的指数是负数，则触发
				<strong>“总和=160”规则</strong>，这意味着内部
				指数变为模160的数字。例如，取1.^-C0
				（<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-C0</span>）。
				这相当于1.^-120，根据“总和=160”规则，就像1.^+40。
				使用大于1的数字转换规则，我们得到
				该数字将被转换为0.0000001^+47，相应地
				跳转地址为01，间接寻址后得到的数字可以直接从寄存器中提取：将是
				<span class="code">&nbsp;0.0000001&nbsp;47</span>
				作为比较，如果取1.^-C1，则“总和=160”规则
				将导致1.^+39，这不适用于转换（9 > 7），这意味着
				数字在间接寻址后不会改变，将保持为
				<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-C1</span>
				（跳转地址等于00）。而且，可以给这个数字加上0，
				以看到
				<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;39</span>。
			</p>
			<p>
				“总和=160”规则还有另一个有趣的副作用。
				详见<a href="#div_neg_zero_degree">负零次幂的数字</a>部分。
			</p>
			<p>
				如果是增加或减少（通过选择寄存器），则尾数
				根据上述规则增加或减少。
			</p>
		</details>

		<details id="div_indirect_addr_reg" open>
			<summary><h4>值是寄存器编号，而不是地址</h4></summary>
			如果间接值代表的不是地址，
			而是寄存器编号，则其编号也由最后两位数字确定，
			分为两种情况：
			<table class="trcenter">
				<tr><th>第一个零</th><th>第一个非零</th></tr>
				<tr><td>00&rarr;R0</td><td>#0&rarr;Ra</td></tr>
				<tr><td>01&rarr;R1</td><td>#1&rarr;Rb</td></tr>
				<tr><td>02&rarr;R2</td><td>#2&rarr;Rc</td></tr>
				<tr><td>03&rarr;R3</td><td>#3&rarr;Rd</td></tr>
				<tr><td>04&rarr;R4</td><td>#4&rarr;Re</td></tr>
				<tr><td>05&rarr;R5</td><td>#5&rarr;R0</td></tr>
				<tr><td>06&rarr;R6</td><td>#6&rarr;R0</td></tr>
				<tr><td>07&rarr;R7</td><td>#7&rarr;R1</td></tr>
				<tr><td>08&rarr;R8</td><td>#8&rarr;R2</td></tr>
				<tr><td>09&rarr;R9</td><td>#9&rarr;R3</td></tr>
				<tr><td>0A&rarr;Ra</td><td>#A&rarr;R4</td></tr>
				<tr><td>0B&rarr;Rb</td><td>#B&rarr;R5</td></tr>
				<tr><td>0C&rarr;Rc</td><td>#C&rarr;R6</td></tr>
				<tr><td>0D&rarr;Rd</td><td>#D&rarr;R7</td></tr>
				<tr><td>0E&rarr;Re</td><td>#E&rarr;R8</td></tr>
				<tr><td>0F&rarr;R0</td><td>#F&rarr;R9</td></tr>
			</table>
		</details>


<details id="div_indirect_addr_using" open>
			<summary><h4>实际应用</h4></summary>
			这里有一个使用间接寻址知识来处理寄存器编号的例子：程序用随机数的逆序填充寄存器R0...R3，同时只使用一个寄存器R0。
			<p>
				<span class="code_num">00.</span><span class="but_cx">Сx</span>&ensp;
				<span class="code_num">01.</span><span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
				<span class="code_num">02.</span><span class="but_k">К</span><span class="op_k">СЧ</span>&ensp;
				<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
				<span class="code_num">04.</span><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
				<span class="code_num">05.</span><span class="but_b">П&rarr;x</span><span class="but">0</span>&ensp;
				<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">x&ge;0</span>&ensp;
				<span class="code_num">07.</span><span class="but">02</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			<p>
				还有其他实用建议。对于БЗ-34来说，减少十六进制数字是从数字E得到其他数字的唯一方法。
				随着МК-61引入二进制运算，这变得简单了，但由于第一个数字
				仍然不受这些运算的控制，因此通过间接寻址
				比通过小数部分和输入指数更快。
			</p>
			<p>
				考虑到循环结束时数字不一定减少的特点，
				实际上数字可能与单位有很大的不同
				（参见上面的例子），这允许使用FLx命令快速
				检查寄存器的值，并在成功/失败时同时跳转。
			</p>
		</details>
	</details>

	<hr>

	<details id="div_x2" open>
		<summary><h3>神秘的寄存器X2</h3></summary>
		这个寄存器实际上在文档中没有提到。实际上，这是那个在ПМК停止时显示在
		显示屏上的寄存器。因此，它有时被称为<em>屏幕</em>寄存器。
		<p>
			文档中指出，这样的寄存器是X，但这不是真的。
			在计算模式下，每执行一条命令后，寄存器X的内容立即
			复制到X2。因此，它们之间没有区别。
			在这种复制过程中，会进行额外的检查
			（例如，检查溢出）。
			显然，为了节省程序模式下的资源，在执行
			大多数(!)命令时不进行这种复制。
			更重要的是（这是最有用的部分），一些命令允许
			进行反向复制。
		</p>

		<details id="div_x2_affect" open>
			<summary><h4>影响X2的命令</h4></summary>
			首先，我们描述一下在执行后会将X的内容复制到X2的命令列表。我们将这样的命令称为
			<strong>影响X2的</strong>命令。
			以下命令<strong>一定会</strong>执行X&rarr;X2的复制：
			<ul>
				<li>
					输入数字（在输入每个数字后，包括分隔符
					<span class="but">.</span>）
				</li>
				<li style="padding: 3px 0">
					<span class="but">/-/</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_cx">Сx</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but">В&uarr;</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">Вx</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">С/П</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">В/О</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">П&rarr;x</span><span class="but">R</span> (R = 0&hellip;F)
				</li>
				<li style="padding: 3px 0">
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
					(R = 0&hellip;F)
				</li>
				<li style="padding: 3px 0">
					空操作码F0&hellip;FF
				</li>
				<li style="padding: 3px 0">
					所有生成错误的命令（由于进入计算模式），
					例如，
					27(<span class="but_k">К</span><span class="but">-</span>)，
					28(<span class="but_k">К</span><span class="but">&times;</span>)，
					29(<span class="but_k">К</span><span class="but">&divide;</span>)，
					2B&hellip;2E, 3C和标准错误操作。
				</li>
			</ul>
			以下命令<strong>只有在没有跳转到地址时</strong>才执行复制：
			<ul>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&lt;0</span>
					（命令<span class="but_k">К</span><span class="op_f">x&lt;0</span>
				 &ndash; 从不影响X2）
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x=0</span>（命令
					<span class="but_k">К</span><span class="op_f">x=0</span> &ndash;
					从不影响X2）
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&ge;0</span>（命令
					<span class="but_k">К</span><span class="op_f">x&ge;0</span> &ndash;
					从不影响X2）
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&ne;0</span>（命令
					<span class="but_k">К</span><span class="op_f">x&ne;0</span> &ndash;
					从不影响X2）
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L0</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L1</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L2</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L3</span>
				</li>
			</ul>
			对于条件操作符，这意味着当条件满足时执行X&rarr;X2的复制。对于循环 &ndash; 当
			循环结束时。
			<p>
				其他操作符不会将X复制到X2。这意味着，例如，
				在执行这些操作时，寄存器X可能包含超级数字
				（大于或等于10<sup>100</sup>）。
				当然，需要考虑到命令本身不进行
				溢出检查。
				例如，
				<span class="but_f">F</span><span class="op_f">10ˣ</span>在执行前会检查参数，
				而<span class="but_f">F</span><span class="op_f">x&sup2;</span>
				则不会。
				为了说明这一点，让我们考虑这样一个程序：
			</p>


<p>
				<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="code_num">01.</span><span class="but">5</span>&ensp;
				<span class="code_num">02.</span><span class="but">0</span>&ensp;
				<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x=0</span>&ensp;
				<span class="code_num">06.</span><span class="but">07</span>&ensp;
				<span class="code_num">07.</span><span class="but_cx">Сx</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			<p>
				可以看出，在第04步中，寄存器X出现了超级数字。
				并且操作符
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x=0</span>
				不会执行，即跳转到地址07（作为跳转地址）。
				根据上面的表格，在这种情况下，X复制到X2
				不会发生，因此不应该出现错误。
				通过运行程序可以很容易验证这一点。
				但是，如果在程序中将操作符替换为
				<span class="codeín">05.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>，
				那么条件将被满足，并且将执行X到X2的复制，
				这将导致错误。
				这也可以通过运行程序来验证。
			</p>
			<p>
				我想指出，命令<span class="but_b">В/О</span>也是
				影响X2的，即如果在从子程序返回之前
				寄存器X中有超级数字，那么将会因错误而停止，
				并且返回操作能够执行。
			</p>
			<p>
				如果不是因为有命令可以进行X2到X的反向复制，
				那么这一切在实践中都没有实际意义。
			</p>
		</details>

		<details id="div_x2_point" open>
			<summary><h4>命令<span class="but">.</span>（代码0A）</h4></summary>
			该命令在程序模式下恢复寄存器X的值为X2的值（除非进行常规数字输入，
			例如1.23，在这种情况下，行为完全符合
			文档并且等同于计算模式）。同时，堆栈的内容不变。此外，该命令在执行影响X2的命令后什么也不做，但这是合乎逻辑的。
			在实践中，这样的命令通常用于节省寄存器，
			较少用于在不改变堆栈的情况下输入。
			<br>
			例子：检查位标志，如果不存在，则设置它。
			假设R9中存储了用于位操作的某个数字，而R1中存储了要检查的位，
			那么以下片段首先会检查位的可用性，
			如果不可用，则设置它：
			<p>
				<span class="code_num">00.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">1</span>&ensp;
				<span class="code_num">02.</span><span class="but_k">К</span><span class="op_k">&and;</span>&ensp;
				<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>&ensp;
				<span class="code_num">05.</span><span class="but">77</span>&ensp;
				&hellip;&ensp;
				<span class="code_num">77.</span><span class="but">.</span>&ensp;
				<span class="code_num">78.</span><span class="but_k">К</span><span class="op_k">&or;</span>&ensp;
				<span class="code_num">79.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
			</p>
			<p>
				结果是，在地址77的操作符<span class="but">.</span>
				将在不移动堆栈的情况下恢复R1到X，这将允许立即执行
				二进制操作。通常，R1中的值不是“计算”出来的，而是
				存储在寄存器中。请注意，选择的是不影响X2的检查与跳转。
			</p>
			<p>
				另一个例子 &ndash; 使用操作符<span class="but">.</span>作为
				子程序的输入参数，即该命令是第一个执行的命令。
				在这种情况下，例如，在用户输入之后（在执行命令
				<span class="but_b">С/П</span>之后，该命令总是将X复制到X2），
				首先执行一些不影响X2的计算（包括
				将这些结果保存到寄存器中），然后调用子程序，
				这样子程序就“看到”了用户的输入。
			</p>
		</details>



<details id="div_x2_exp" open>
			<summary><h4>命令<span class="but">ВП</span>（代码0C）</h4></summary>
			对于这个命令，存在几个恢复条件和规则。
			请注意，在影响X2的命令之后，它的行为将如
			文档所述。即使它被非标准地使用（并执行某种恢复），在其
			执行后输入数字仍将被视为输入指数。
			<ul>
				<li>
					<details id="div_x2_exp_SR" open>
						<summary>
							<h4>丢弃第一个数字恢复X2</h4>
						</summary>
						在执行一系列操作符
						<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
						<span class="but">ВП</span>之后执行此操作，
						其中R是任意内存寄存器。此时，寄存器X的当前内容丢失，堆栈不变。代替
						<span class="but_b">x&rarr;П</span><span class="but">R</span>
						可以是命令
						<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>。
						<p>
							例子。假设我们需要处理用户输入的选择，用于
							在某个3D迷宫中移动。通常使用键
							2,4,6,8,&plusmn;5（对应移动方向）。
							考虑以下序列（假设用户选择存储在寄存器R9中，且0值还有其他含义）：
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
							<span class="code_num">01.</span><span class="but">2</span>&ensp;
							<span class="code_num">02.</span><span class="but">&divide;</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>&ensp;
							<span class="code_num">04.</span><span class="but">77</span>&ensp;
							<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">06.</span><span class="but">+</span>&ensp;
							<span class="code_num">07.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">08.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">09.</span><span class="but_f">F</span><span class="op_f">x=0</span>&ensp;
							<span class="code_num">10.</span><span class="but">55</span>&ensp;
							<span class="code_num">11.</span><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>
						</p>
						<p>
							这里发生了什么？在第二步中，我们将得到一个数字
							1, 2, 3, 4, &plusmn;2.5或0。条件操作符不仅
							排除了零的情况，还执行了X&rarr;X2。接下来，我们立即将得到的
							数字加上<big>&pi;</big>并保存在R9中
							以便后续间接
							寻址（假设R4...R7存储用于执行移动的乘法系数）。请注意，这里没有使用
							影响X2的命令。在执行命令<span class="but">ВП</span>之后，我们
							将在X中“恢复”步骤02之后除法的结果，
							只是没有第一个数字，即零（对于1...4）或&plusmn;0.5，
							以便用于程序后续的分支
							（乘以除法系数，对于&plusmn;0.5可以取数字的符号等）。如果不使用<span class="but">ВП</span>
							则需要使用额外的
							寄存器或额外的堆栈操作命令。
						</p>
						<p>
							附加条件。<strong>如果</strong>X2的内容
							等于<strong>零</strong>，
							那么将恢复<strong>一</strong>。
						</p>
						<p>
							如果在恢复时（执行命令
							<span class="but">ВП</span>）寄存器
							<strong>X的内容小于零</strong>，
							那么在删除X2数字的第一个数字的位置，
							它将被<strong>替换为9</strong>。
							<br>
							例如，在执行程序后
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</<span class="op_f">&pi;</span>&ensp;
							<span class="code_num">01.</span><span class="but">/-/</span>&ensp;
							<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">03.</span><span class="but">&times;</span>&ensp;
							<span class="code_num">04.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							屏幕上将显示<span class="code">-9.1415926&nbsp;&nbsp;&nbsp;</span>在
							R9中将是-<big>&pi;</big> &times; <big>&pi;</big>
							（地址01处的命令影响X2）。
						</p>
						<p>
							根据<a href="#div_glos_zero_digit">符号数字</a>的知识
							可以得出更简单的规则：这个序列
							在恢复X2时（如果X2不是零）将第一个数字替换为
							寄存器X中的数字减1的符号数字。那么对于普通
							数字得到：
						</p>
						
<ul>
							<li>
								数字大于零，符号数字等于一，意味着第一个
								数字被替换为零，即删除。
							</li>
							<li>
								数字小于零，带有负号，符号数字等于10（A），意味着
								数字被替换为9
							</li>
						</ul>
					</details>
				</li>
				<li>

<details id="div_x2_exp_combine" open>
						<summary>
							<h4>恢复X2并将第一个数字替换为X中的数字</h4>
						</summary>
						这通常是最有趣的序列。
						它允许以非标准方式组合两个数字。
						<p>
							考虑序列
							<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="but">ВП</span>。
							这里<span class="but_k">К</span><span class="op_k">НОП</span>被认为是
							更中性的，也可以是其他不影响X2的命令，
							我们称之为第一个命令。这里重要的是要考虑：
						</p>
						<ol>
							<li>
								作为第一个数字的样本，取X的内容(!)
								在开始该序列之前。
							</li>
							<li>
								如果代替<span class="but_k">К</span><span class="op_k">НОП</span>
								的是另一个不影响X2的命令，那么它将被执行，但其
								执行结果将丢失。同时，堆栈将像往常一样在执行命令后保持状态。
							</li>
							<li>
								如果第一个命令是跳转到另一个地址，那么它
								将被执行，并且带有<span class="but">ВП</span>的序列将被中断。
							</li>
							<li>
								如果第一个命令产生错误，那么带有<span class="but">ВП</span>的序列
								也将被中断。
							</li>
							<li>
								如果第一个命令是
								<span class="but_b">x&rarr;П</span><span class="but">R</span>，那么将
								按照上述规则执行，丢弃第一个数字。
							</li>
						</ol>
						<p>
							例子：
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">02.</span><span class="but_k">К</span><span class="op_k">ЗН</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">Вx</span>&ensp;
							<span class="code_num">04.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">07.</span><span class="but_b">С/П</span>
						</p>
						<p>
							结果我们将得到<span class="code">1.ELE-6Г9&nbsp;&nbsp;&nbsp;</span>。
							这里小数部分很清楚 &ndash; 这是数字<big>&pi;</big>的倒数
							该数字由地址03处的影响X2的命令保存。而这里有趣的
							是第一位上的数字1，它是通过命令
							<span class="but_k">К</span><span class="op_k">ЗН</span>出现在堆栈中的。
							正是在恢复过程中，它代替了八。
						</p>
						<p>
							有趣的是，第一个数字也可以是十六进制的，这样
							就可以得到在计算模式下很难实现的东西。
							例如，
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">9</span>&ensp;
							<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
							<span class<p>
							<span class="code_num">03.</span><span class="but">5</span>&ensp;
							<span class="code_num">04.</span><span class="but">&times;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">06.</span><span class="but">/-/</span>&ensp;
							<span class="code_num">07.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">08.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">09.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">10.</span><span class="but">/-/</span>&ensp;
							<span class="code_num">11.</span><span class="but">9</span>&ensp;
							<span class="code_num">12.</span><span class="but">9</span>&ensp;
							<span class="code_num">13.</span><span class="but_b">С/П</span>
						</p>
						<p>
							将会是10(!)个"负号"。
							<span class="code">--.--------99</span>。这里
							地址06处的影响X2的命令固定了8.AAAAAAA
							（同时加上负号），而小数部分的操作符在第一位置留下了
							也是数字A。所有这些序列与
							<span class="but">ВП</span>成功结合，末尾的-99是为了美观而添加的。
						</p>
						<p>
							再举一个例子。假设需要一个子程序，它能够将寄存器X中小数部分的第一个数字（整数部分）
							转换为字母。例如，1&rarr;E, 2&rarr;D,&hellip; 4&rarr;A。
							在计算模式下，为此可以使用以下序列
						</p>
						<p>
							<span class="code_num">00.</span><span class="but">1</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">02.</span><span class="but">+</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but">1</span>&ensp;
							<span class="code_num">07.</span><span class="but_k">К</span><span class="op_k">[x]</span>
						</p>
						<p>
							考虑到在程序模式下执行命令<span class="but">ВП</span>的特殊性，还需要在执行命令
							<span class="but_k">К</span><span class="op_k">{x}</span>之后复制X&rarr;X2，即
						</p>
						<p>
							<span class="code_num">00.</span><span class="but">1</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">02.</span><span class="but">+</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">05.</span><span class="but">В&uarr;</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">07.</span><span class="but">1</span>&ensp;
							<span class="code_num">08.</span><span class="but_k">К</span><span class="op_k">[x]</span>
						</p>
						<p>
							这是一个+1命令，而且堆栈会被破坏。考虑
						</p>
						<p>
							<span class="code_num">00.</span><span class="but">1</span>&ensp;
							<span class="code_num">01.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
							<span class="code_num">02.</span><span class="but">+</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</��<p>
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>
						</p>
						<p>
							这里，由于恢复了单位（步骤0），在步骤06，
							将只剩下一个十六进制数字。
							这样，未记录的序列使子程序缩短了两步。
						</p>
						<p>
							需要理解的是，如果X2中的数字没有规范化，那么仍然
							会替换第一个数字。让我们利用间接寻址的知识：
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">4</span>&ensp;
							<span class="code_num">02.</span><span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span>&ensp;
							<span class="code_num">04.</span><span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">07.</span><span class="but_b">С/П</span>
						</p>
						<p>
							在这种情况下，4在间接跳转后变为00000004，
							这意味着替换第一个数字将导致
							<span class="code">&nbsp;40000004.&nbsp;&nbsp;&nbsp;</span>，
							通过运行程序可以很容易验证这一点。
						</p>
						<p>
							现在让我们考虑特殊情况。如果在序列开始之前<strong>X</strong>
							<strong>是零</strong>，那么
							代替第一个数字的是零。通常这意味着数字将没有第一个
							数字（起始零不重要）。但如果它已经这样了
							（例如，数字 &ndash; 是带有前导零的间接寻址的结果），
							那么就不会有任何有用的操作。
							不过，有时，正是这种差异可以被用来
							了解是否执行了间接寻址。
						</p>
						<p>
							如果<strong>X2是零</strong>，那么这里似乎出现了
							<span class="but">ВП</span>的众所周知的技巧，它将0
							转换为1。
							在这种情况下，X的第一个数字增加1。以下是一个片段：
						</p>

<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">03.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							如果给这个程序输入5，它会输出6。如果是9，
							它会输出&hellip; A(!)，然后依次是B, C, D, E, F。不过，
							最好立即将其替换为0并清理堆栈 &ndash;
							空洞是狡猾的（无论如何，如果输入F，
							程序肯定会扭曲成无法辨认的东西）。
							再举一个例子：
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">С/П</span>
						</p>
						<p>
							输入
							<span class="code">-9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
							输出的第一位数字是相反数的
							<span class="code">-1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
						</p>
					</details>
				</li>
				<li>
					<details id="div_x2_exp_goto" open>
						<summary>
							<h4>间接跳转后立即<span class="but">ВП</span></h4>
						</summary>
						即在程序中通过命令
						<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
						进行跳转，或者在检查条件时跳转，例如，
						<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
						然后直接在跳转到的地方执行命令
						<span class="but">ВП</span>。
						在这种情况下，也会进行X2的恢复，但此时
						<strong>第一个数字变为7</strong>。
						符号和指数保持不变。与之前类似，如果X2中的数字没有规范化，
						那么仍然会替换第一个数字，其余的保持不变。
						如果<strong>X2 = 0</strong>，数字将被
						恢复为<strong>8</strong>。
						<p>
							对于条件跳转，只有当进行跳转到
							地址时才有效。如果条件满足（即没有跳转），
							则行为如上所述（实际上命令将被
							忽略）。如果跳转后不是
							<span class="but">ВП</span>，那么也按照之前
							<span class="but">ВП</span>的规则。例子。
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">03.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							如果给这个程序输入5，它会输出6。如果是9，
							它会输出&hellip; A(!)，然后依次是B, C, D, E, F。不过，
							最好立即将其替换为0并清理堆栈 &ndash;
							空洞是狡猾的（无论如何，如果输入F，
							程序肯定会扭曲成无法辨认的东西）。
							再举一个例子：
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">С/П</span>
						</p>
						<p>
							输入
							<span class="code">-9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
							输出的第一位数字是相反数的
							<span class="code">-1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
						</p>
					</details>
				</li>
				<li>
					<details id="div_x2_exp_goto" open>
						<summary>
							<h4>间接跳转后立即<span class="but">ВП</span></h4>
						</summary>
						即在程序中通过命令
						<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
						进行跳转，或者在检查条件时跳转，例如，
						<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
						然后直接在跳转到的地方执行命令
						<span class="but">ВП</span>。
						在这种情况下，也会进行X2的恢复，但此时
						<strong>第一个数字变为7</strong>。
						符号和指数保持不变。与之前类似，如果X2中的数字没有规范化，
						那么仍然会替换第一个数字，其余的保持不变。
						如果<strong>X2 = 0</strong>，数字将被
						恢复为<strong>8</strong>。
						<p>
							对于条件跳转，只有当进行跳转到
							地址时才有效。如果条件满足（即没有跳转），
							则行为如上所述（实际上命令将被
							忽略）。如果跳转后不是
							<span class="but">ВП</span>，那么也按照之前
							<span class="but">ВП</span>的规则。例子。
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class="code_num">02.</span><span class="but">0</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">x&rarr;П</span><span class="but">8</span>&ensp;
							<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="but_b">БП</span><span class="but">8</span>&ensp;
							&hellip;&ensp;
							<span class="code_num">10.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">11.</span><span class="but_b">С/П</span>
						</p>
						<p>
							停止后屏幕上将显示
							<span class="code">&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
							即恢复X2 = 10（而不是100），并且第一个数字被替换为7。
							再举一个例子。
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">02.</span><span class="but">8</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
							<span class="code_num">05.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
							<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">07.</span><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span>&ensp;
							<span class="code_num">08.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">09.</span><span class="but_b">С/П</span>
						</p>
						<p>
							根据已指出的规则，将会是
							<span class="code">&nbsp;70000008.&nbsp;&nbsp;&nbsp;</span>。如果
							将地址07处的命令替换为
							<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span>，
							那么什么也不会改变，因为条件不会满足并且会发生跳转。
							但如果替换为
							<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">9</span>，
							那么条件会满足，不会发生跳转，并且会使用旧规则，
							即会使用X中的第一个数字，即
							<span class="code">&nbsp;30000008.&nbsp;&nbsp;&nbsp;</span>。
						</p>
					</details>




<li>
					<details id="div_x2_exp_plus" open>
						<summary>
							<h4>使用<span class="but">ВП</span>作为加法</h4>
						</summary>
						这是一个罕见的情况，主要是为了提供信息。序列
						<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but">ВП</span>。
						当X2为零时，首先，如前所述，X将增加一，第二个<span class="but">ВП</span>将增加
						到增加前的数字大小。随后的<span class="but">ВП</span>添加不再改变任何东西。例子：
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">02.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">04.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							输入6，输出D（6 + 7 = 13）。输入D，输出
							B（13 + 14 = 27 = 16 + 11）。
						</p>
					</details>
				</li>

<li>
					<details id="div_x2_exp_down" open>
						<summary>
							<h4>命令<span class="but">.</span>在<span class="but">ВП</span>之前
							将X的捕获“深入”到开始处</h4>
						</summary>
						通常命令<span class="but">.</span>在X中恢复X2的值，
						但<span class="but">ВП</span>也尝试恢复X2，
						但是取的是在X中距离它两步之前的那个数字的第一位。考虑
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class="code_num">02.</span><span class="but">5</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
							<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">.</span>&ensp;
							<span class="code_num">07.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">08.</span><span class="but_b">С/П</span>
						</p>
						<p>
							结果是55，因为
							15&sup2; = 225, 225&sup2; = <strong>5</strong>0625，而<span class="but">ВП</span>“获胜”，
							它将恢复X2(15)，第一位数字是5。如果去掉第二个
							<span class="but_k">К</span><span class="op_k">НОП</span>，那么
							结果将是25（225的2），即第二个
							<span class="but_f">F</span><span class="op_f">x&sup2;</span>
							将被忽略，就好像命令
							<span class="but">.</span>将<span class="but">ВП</span>推到了更深处。
							如果交换
							<span class="but_k">К</span><span class="op_k">НОП</span>和
							<span class="but">.</span>的位置，那么结果将是15，因为
							<span class="but">.</span>恢复了15，然后<span class="but">ВП</span>就像在手动模式下工作一样。
							另一个例子：
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class="code_num">02.</span><span class="but">5</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">04.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">.</span>&ensp;
							<span class="code_num">07.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">08.</span><span class="but_b">С/П</span>
						</p>
						<p>
							这里<span class="but">.</span>将<span class="but_b">x&rarr;П</span><span class="but">9</span>推到了更深处，
							即恢复为15，数字为3，即35。如果去掉
							<span class="but_k">К</span><span class="op_k">НОП</span>，那么
							行为将如同
							<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="but">ВП</span>，即15没有第一位数字（5）"。
						</p>
					</details>
				</li>
			</ul>
		</details>

<details id="div_x2_sum" open>
			<summary><h4>总结</h4></summary>
			<span class="but">ВП</span>和<span class="but">.</span>命令的非标准行为原因是
			ПМК中输入数字的子程序，包括其指数，
			直接与X2寄存器一起工作。
			考虑一个涉及另一个输入数字命令的例子：
			<p>
				<span class="code_num">01.</span><span class="but">B&uarr;</span>&ensp;
				<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
				<span class="code_num">03.</span><span class="but">2</span>&ensp;
				<span class="code_num">04.</span><span class="but">/-/</span>&ensp;
				<span class="code_num">05.</span><span class="but_b">С/П</span>
			</p>
			显然，这里将发生除以100的操作。这段代码的行为符合
			文档描述。我们稍微补充一下：
			<p>
				<span class="code_num">01.</span><span class="but">B&uarr;</span>&ensp;
				<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
				<span class="code_num">03.</span><span class="but">2</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">07.</span><span class="but">/-/</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			如果看起来，在输入指数（乘以100）之后
			我们又取了<big>&pi;</big>，两次平方它，然后取负值。
			实际上，这个片段做的事情和第一个一样！
			输入数字的操作与X2一起工作，在此期间所有命令都
			不是影响X2的，它们当然会被执行，但结果将在执行命令
			<span class="but">/-/</span>时被丢弃，该命令将继续输入
			数字（在本例中是指数的值）到X2寄存器。
			可以通过查看堆栈的内容来了解
			中间命令是否已执行 &ndash; 在Y寄存器中将存储输入值乘以100，
			而在X1中 &ndash; <big>&pi;</big>的平方。
			<p>
				再举一个例子。众所周知（尽管没有文档记录），为了禁止在输入指数时输入小数点，
				<span class="but">ВП</span>和<span class="but">.</span>命令的组合会产生错误。更重要的是，与其他
				引发错误的方式不同，它
			</p>
			<ol>
				<li>它是最快的，立即作用，而不是“思考”。</li>
				<li>
					它在程序模式下不会跳过多余的命令，就像所有其他引发错误的操作一样（啊，这也是没有
					文档记录的）。
				</li>
			</ol>
			<p>
				但这种组合也与X2一起工作，即忽略所有不
				影响X2的命令。由此可以清楚地看出，以下片段：
			</p>
			<p>
				<span class="code_num">01.</span><span class="but">B&uarr;</span>&ensp;
				<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">03.</span><span class="but">ВП</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">06.</span><span class="but">.</span>&ensp;
				<span class="code_num">07.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			将因错误而在命令<span class="but">.</span>处停止（即下一个
			执行的地址将是07）并且只会平方两次
			（第一个平方，作为非X2影响的将被<span class="but">ВП</span>命令丢弃）。
		</details>
	</details>

<hr>

<details id="div_hex" open>
	<summary><h3>十六进制算术</h3></summary>
	这里讨论的是普通的算术运算，但是在操作数是一个包含十六进制数字
A...E的数字的情况下（出于安全考虑，至少作为第一个数字，F被排除在外）。
<p>
	为了简单起见，我们考虑一个由一个
	十六进制数字组成的数字的情况。接下来我们将用字母H表示它。为了更清楚地表示操作数，我们将使用标准的表示方法X和Y。
</p>

<details id="div_hex_h_plus_y" open>
	<summary><h4>操作 H <span class="but">+</span> Y</h4></summary>
	<table class="trcenter">
		<tr>
			<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
			<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
		</tr>
<tr>
					<th>0</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>1</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>2</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>0</td>
				</tr>
				<tr>
					<th>3</th>
					<td>3</td><td>4</td><td>5</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>4</td><td>5</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>5</th>
					<td>5</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>6</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>7</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>8</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
				</tr>
				<tr>
					<th>A</th>
					<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
				</tr>
				<tr>
					<th>B</th>
					<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
				</tr>
				<tr>
					<th>C</th>
					<td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
				</tr>
				<tr>
					<th>D</th>
					<td>7</td><td>8</td><td>9</td><td>10</td><td>11</td>
				</tr>
				<tr>
					<th>E</th>
					<td>8</td><td>9</td><td>10</td><td>11</td><td>12</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>10</td><td>21</td><td>22</td><td>24</td><td>24</td>
				</tr>
				<tr>
					<th>11</th>
					<td>21</td><td>22</td><td>23</td><td>24</td><td>25</td>
				</tr>
				<tr>
					<th>12</th>
					<td>22</td><td>23</td><td>24</td><td>25</td><td>26</td>
				</tr>
				<tr>
					<th>13</th>
					<td>23</td><td>24</td><td>25</td><td>26</td><td>27</td>
				</tr>
				<tr>
					<th>14</th>
					<td>24</td><td>25</td><td>26</td><td>27</td><td>28</td>
				</tr>
				<tr>
					<th>15</th>
					<td>25</td><td>26</td><td>27</td><td>28</td><td>29</td>
				</tr>
				<tr>
					<th>16</th>
					<td>26</td><td>27</td><td>28</td><td>29</td><td>30</td>
				</tr>
				<tr>
					<th>17</th>
					<td>27</td><td>28</td><td>29</td><td>30</td><td>31</td>
				</tr>
				<tr>
					<th>18</th>
					<td>28</td><td>29</td><td>30</td><td>31</td><td>32</td>
				</tr>
				<tr>
					<th>19</th>
					<td>29</td><td>30</td><td>31</td><td>32</td><td>33</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>30</td><td>31</td><td>32</td><td>33</td><td>34</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>31</td><td>32</td><td>33</td><td>34</td><td>35</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>32</td><td>33</td><td>34</td><td>35</td><td>20</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>33</td><td>34</td><td>35</td><td>20</td><td>21</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>34</td><td>35</td><td>20</td><td>21</td><td>22</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>35</td><td>20</td><td>21</td><td>22</td><td>23</td>
				</tr>
			</table>


<p>
				计算按照十六进制进行，余数取模16，然后取其最后一位数字（以保持一位）。
				X = ((X + Y) mod 16) mod 10。
				<br>
				如果<strong>Y是两位数</strong>，那么就有两位数字X = ((X + Y) mod 256)
				mod 100，这意味着如果数字是两位数，结果就<strong>像普通加法一样</strong>。
				<br>
				如果<strong>Y是小数</strong>，那么整数部分如上所述，
				而小数部分保持不变。
			</p>
		</details>

		<details id="div_hex_x_plus_h" open>
			<summary><h4>操作 X <span class="but">+</span> H</h4></summary>
			在这种情况下，执行普通的加法，只是结果需要规范化。例如：0 + A = 10, 9 + E = 23。如果是十六进制的X，请参见上表。
		</details>

		<details id<pot>
				<summary><h4>操作 Y <span class="but">-</span> H</h4></summary>
				<table class="trcenter">
					<tr>
						<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
						<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
					</tr>


<tr>
					<th>0</th>
					<td>-10</td><td>-1</td><td>-2</td><td>-3</td><td>-4</td>
				</tr>
				<tr>
					<th>1</th>
					<td>-9</td><td>-10</td><td>-1</td><td>-2</td><td>-3</td>
				</tr>
				<tr>
					<th>2</th>
					<td>-8</td><td>-9</td><td>-10</td><td>-1</td><td>-2</td>
				</tr>
				<tr>
					<th>3</th>
					<td>-7</td><td>-8</td><td>-9</td><td>-10</td><td>-1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>-6</td><td>-7</td><td>-8</td><td>-9</td><td>-10</td>
				</tr>
				<tr>
					<th>5</th>
					<td>-5</td><td>-6</td><td>-7</td><td>-8</td><td>-9</td>
				</tr>
				<tr>
					<th>6</th>
					<td>-4</td><td>-5</td><td>-6</td><td>-7</td><td>-8</td>
				</tr>
				<tr>
					<th>7</th>
					<td>-3</td><td>-4</td><td>-5</td><td>-6</td><td>-7</td>
				</tr>
				<tr>
					<th>8</th>
					<td>-2</td><td>-3</td><td>-4</td><td>-5</td><td>-6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>-1</td><td>-2</td><td>-3</td><td>-4</td><td>-5</td>
				</tr>
				<tr>
					<th>A</th>
					<td>0</td><td>-1</td><td>-2</td><td>-3</td><td>-4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>1</td><td>0</td><td>-1</td><td>-2</td><td>-3</td>
				</tr>
				<tr>
					<th>C</th>
					<td>2</td><td>1</td><td>0</td><td>-1</td><td>-2</td>
				</tr>
				<tr>
					<th>D</th>
					<td>3</td><td>2</td><td>1</td><td>0</td><td>-1</td>
				</tr>
				<tr>
					<th>E</th>
					<td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>0</td><td>15</td><td>14</td><td>13</td><td>12</td>
				</tr>
				<tr>
					<th>11</th>
					<td>1</td><td>16</td><td>15</td><td>14</td><td>13</td>
				</tr>
				<tr>
					<th>12</th>
					<td>2</td><td>17</td><td>16</td><td>15</td><td>14</td>
				</tr>
				<tr>
					<th>13</th>
					<td>3</td><td>18</td><td>17</td><td>16</td><td>15</td>
				</tr>
				<tr>
					<th>14</th>
					<td>4</td><td>19</td><td>18</td><td>17</td><td>16</td>
				</tr>
				<tr>
					<th>15</th>
					<td>5</td><td>20</td><td>19</td><td>18</td><td>17</td>
				</tr>
				<tr>
					<th>16</th>
					<td>6</td><td>21</td><td>20</td><td>19</td><td>18</td>
				</tr>
				<tr>
					<th>17</th>
					<td>7</td><td>22</td><td>21</td><td>20</td><td>19</td>
				</tr>
				<tr>
					<th>18</th>
					<td>8</td><td>23</td><td>22</td><td>21</td><td>20</td>
				</tr>
				<tr>
					<th>19</th>
					<td>9</td><td>24</td><td>23</td><td>22</td><td>21</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>0</td><td>25</td><td>24</td><td>23</td><td>22</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>1</td><td>10</td><td>25</td><td>24</td><td>23</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>2</td><td>11</td><td>10</td><td>25</td><td>24</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>3</td><td>12</td><td>11</td><td>10</td><td>25</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>4</td><td>13</td><td>12</td><td>11</td><td>10</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>5</td><td>14</td><td>13</td><td>12</td><td>11</td>
				</tr>
			</table>

<p>
				看起来像是X = (Y - X) mod 16，但并不总是清楚，
				何时
				采用借位，何时不采用。数字A对于两位数来说有些特别。
				<br>
				对于三位数及以上，重复两位数的规则，
				即100 - A = 90, 100 - B = 105，...，
				109 - E = 111。
			</p>
		</details>

		<details id="div_hex_h_minus_x" open>
			<summary><h4>操作 H <span class="but">-</span> X</h4></summary>

<table class="trcenter">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>10</td><td>11</td><td>12</td><td>13</td><td>14</td>
				</tr>
				<tr>
					<th>1</th>
					<td>9</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>2</th>
					<td>8</td><td>9</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>3</th>
					<td>7</td><td>8</td><td>9</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>6</td><td>7</td><td>8</td><td>9</td><td>0</td>
				</tr>
				<tr>
					<th>5</th>
					<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
				</tr>
				<tr>
					<th>6</th>
					<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
				</tr>
				<tr>
					<th>7</th>
					<td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
				</tr>
				<tr>
					<th>8</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>A</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>-1</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>C</th>
					<td>-2</td><td>-1</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>D</th>
					<td>-3</td><td>-2</td><td>-1</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>E</th>
					<td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>11</th>
					<td>-1</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>12</th>
					<td>-2</td><td>-1</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>13</th>
					<td>-3</td><td>-2</td><td>-1</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>14</th>
					<td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>0</td>
				</tr>
				<tr>
					<th>15</th>
					<td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td>
				</tr>
				<tr>
					<th>16</th>
					<td>-6</td><td>-5</td><td>-4</td><td>-3</td><td>-2</td>
				</tr>
				<tr>
					<th>17</th>
					<td>-7</td><td>-6</td><td>-5</td><td>-4</td><td>-3</td>
				</tr>
				<tr>
					<th>18</th>
					<td>-8</td><td>-7</td><td>-6</td><td>-5</td><td>-4</td>
				</tr>
				<tr>
					<th>19</th>
					<td>-9</td><td>-8</td><td>-7</td><td>-6</td><td>-5</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>-10</td><td>-9</td><td>-8</td><td>-7</td><td>-6</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>-1</td><td>-10</td><td>-9</td><td>-8</td><td>-7</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>-2</td><td>-1</td><td>-10</td><td>-9</td><td>-8</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>-3</td><td>-2</td><td>-1</td><td>-10</td><td>-9</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>-10</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td>
				</tr>
			</table>

<p>
				只有少数数字违反常规减法规则（从B - 1开始，向上和向右，对于两位数则是从A - 1B开始，向下和向左）。
				<br>
				顺便说一下，有一个特点：当从一个十六进制数中减去它的十进制对应数时，实际上零并不是规范化的
				（即从四位数的0000），这可以用来在任何程度上获得零。例如（在手动模式下）：
			</p>
			<ol>
				<li>
					以文档中描述的方式获得数字E：
					<span class="but">1</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
					<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
					<span class="but">ВП</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">[x]</span>，
					或者可以用非标准的方式：
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&times;</span>&ensp;
					<span class="but">ВП</span>
				</li>
				<li>
					添加我们想要获得的指数：
					<span class="but">ВП</span>&ensp;
					<span class="but">9</span>&ensp;
					<span class="but">9</span>
				</li>
				<li>
					然后将其复制到堆栈：
					<span class="but">В&uarr;</span>&ensp;
					<span class="but">В&uarr;</span>&ensp;
					<span class="but_cx">СX</span>
				</li>
				<li>
					执行加法（与零）和减法：
					<span class="but">+</span>&ensp;
					<span class="but">-</span>
				</li>
			</ol>

<p>
				就这样我们得到了
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99</span>。
			</p>
		</details>

		<details id="div_hex_h_mult_y" open>
			<summary><h4>操作 H <span class="but">&times;</span> Y</h4></summary>

<table class="trcenter">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<th>1</th>
					<td>10</td><td>10</td><td>10</td><td>10</td><td>0</td>
				</tr>
				<tr>
					<th>2</th>
					<td>20</td><td>20</td><td>20</td><td>20</td><td>0</td>
				</tr>
				<tr>
					<th>3</th>
					<td>30</td><td>30</td><td>30</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<th>4</th>
					<td>40</td><td>40</td><td>40</td><td>40</td><td>0</td>
				</tr>
				<tr>
					<th>5</th>
					<td>50</td><td>50</td><td>50</td><td>50</td><td>0</td>
				</tr>
				<tr>
					<th>6</th>
					<td>60</td><td>60</td><td>60</td><td>60</td><td>0</td>
				</tr>
				<tr>
					<th>7</th>
					<td>70</td><td>70</td><td>70</td><td>70</td><td>0</td>
				</tr>
				<tr>
					<th>8</th>
					<td>80</td><td>80</td><td>80</td><td>80</td><td>0</td>
				</tr>
				<tr>
					<th>9</th>
					<td>90</td><td>90</td><td>90</td><td>90</td><td>0</td>
				</tr>
				<tr>
					<th>A</th>
					<td>00</td><td>00</td><td>00</td><td>00</td><td>0</td>
				</tr>
				<tr>
					<th>B</th>
					<td>10</td><td>10</td><td>10</td><td>10</td><td>0</td>
				</tr>
				<tr>
					<th>C</th>
					<td>20</td><td>20</td><td>20</td><td>20</td><td>0</td>
				</tr>
				<tr>
					<th>D</th>
					<td>30</td><td>30</td><td>30</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<th>E</th>
					<td>40</td><td>40</td><td>40</td><td>40</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>100&nbsp;</td><td>100</td><td>100</td><td>100</td><td>0</td>
				</tr>
				<tr>
					<th>11</th>
					<td>110</td><td>110</td><td>110</td><td>110</td><td>0</td>
				</tr>
				<tr>
					<th>12</th>
					<td>120</td><td>120</td><td>120</td><td>120</td><td>0</td>
				</tr>
				<tr>
					<th>13</th>
					<td>130</td><td>130</td><td>130</td><td>130</td><td>0</td>
				</tr>
				<tr>
					<th>14</th>
					<td>140</td><td>140</td><td>140</td><td>140</td><td>0</td>
				</tr>
				<tr>
					<th>15</th>
					<td>150</td><td>150</td><td>150</td><td>150</td><td>0</td>
				</tr>
				<tr>
					<th>16</th>
					<td>160</td><td>160</td><td>160</td><td>160</td><td>0</td>
				</tr>
				<tr>
					<th>17</th>
					<td>170</td><td>170</td><td>170</td><td>170</td><td>0</td>
				</tr>
				<tr>
					<th>18</th>
					<td>180</td><td>180</td><td>180</td><td>180</td><td>0</td>
				</tr>
				<tr>
					<th>19</th>
					<td>190</td><td>190</td><td>190</td><td>190</td><td>0</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>200</td><td>200</td><td>200</td><td>200</td><td>0</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>210</td><td>210</td><td>210</td><td>210</td><td>0</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>220</td><td>220</td><td>220</td><td>220</td><td>0</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>230</td><td>230</td><td>230</td><td>230</td><td>0</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>240</td><td>240</td><td>240</td><td>240</td><td>0</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>250</td><td>250</td><td>250</td><td>250</td><td>0</td>
				</tr>
			</table>

<p>
				令人惊讶的单调性，几乎所有的行为都像10一样。不清楚E有什么不同，但是即使是多位数也会得到零。
				<br>
				对于两位数来说，相应地，C &times; 20 = 200，但E &times; 20 = 0。
			</p>
		</details>

		<details id="div_hex_x_mult_h" open>
			<summary><h4>操作 X <span class="but">&times;</span> H</h4></summary>

<table class="trcenter">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<th>1</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>2</th>
					<td>4</td><td>6</td><td>8</td><td>10</td><td>12</td>
				</tr>
				<tr>
					<th>3</th>
					<td>4</td><td>1</td><td>4</td><td>23</td><td>10</td>
				</tr>
				<tr>
					<th>4</th>
					<td>8</td><td>2</td><td>0</td><td>20</td><td>24</td>
				</tr>
				<tr>
					<th>5</th>
					<td>50</td><td>11</td><td>32</td><td>53</td><td>42</td>
				</tr>
				<tr>
					<th>6</th>
					<td>0</td><td>22</td><td>44</td><td>50</td><td>40</td>
				</tr>
				<tr>
					<th>7</th>
					<td>10</td><td>33</td><td>40</td><td>63</td><td>54</td>
				</tr>
				<tr>
					<th>8</th>
					<td>20</td><td>44</td><td>52</td><td>60</td><td>68</td>
				</tr>
				<tr>
					<th>9</th>
					<td>30</td><td>55</td><td>64</td><td>73</td><td>82</td>
				</tr>
				<tr>
					<th>A</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>B</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>C</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>D</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>E</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>11</th>
					<td>10</td><td>21</td><td>32</td><td>43</td><td>54</td>
				</tr>
				<tr>
					<th>12</th>
					<td>04</td><td>16</td><td>28</td><td>40</td><td>52</td>
				</tr>
				<tr>
					<th>13</th>
					<td>14</td><td>11</td><td>24</td><td>53</td><td>50</td>
				</tr>
				<tr>
					<th>14</th>
					<td>08</td><td>22</td><td>20</td><td>50</td><td>4</td>
				</tr>
				<tr>
					<th>15</th>
					<td>990</td><td>021</td><td>052</td><td>923</td><td>922</td>
				</tr>
				<tr>
					<th>16</th>
					<td>000</td><td>032</td><td>904</td><td>920</td><td>920</td>
				</tr>
				<tr>
					<th>17</th>
					<td>010</td><td>043</td><td>900</td><td>933</td><td>934</td>
				</tr>
				<tr>
					<th>18</th>
					<td>020</td><td>054</td><td>912</td><td>930</td><td>948</td>
				</tr>
				<tr>
					<th>19</th>
					<td>030</td><td>905</td><td>924</td><td>943</td><td>962</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
			</table>

<p>
				这里已经很难用逻辑来解释了。
				实际上，作者以某种方式使用了D。一方面，这是一个
				图像，另一方面 &ndash; 是系数10（见表H &times; Y），
				而最基本的是检查位移位。当乘以包含1、2、4、8（作为位）的小数部分时，可能会超出范围，
				即0.5或1.6。因此，根据指示的表格，乘以D的结果，
				如果一切正常，则得到一个数字，如果超出范围，则得到两个数字。
			</p>
			<p>
				对于两位数的结果，有时会是非规范化的：请注意某些情况下的前导零。在这种背景下
				14 &times; E看起来像一只白乌鸦。
			</p>
		</details>

		<details id="div_hex_h_div_x" open>
			<summary><h4>操作 H <span class="but">&divide;</span> X</h4></summary>


<table class="trcenter">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td>
				</tr>
				<tr>
					<th>1</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>2</th>
					<td>5</td><td>5.5</td><td>6</td><td>6.5</td><td>7</td>
				</tr>
				<tr>
					<th>3</th>
					<td>3.3333333</td><td>3.6666666</td><td>4</td><td>4.3333333</td><td>4.6666666</td>
				</tr>
				<tr>
					<th>4</th>
					<td>2.5</td><td>2.75</td><td>3</td><td>3.25</td><td>3.5</td>
				</tr>
				<tr>
					<th>5</th>
					<td>2</td><td>2.2</td><td>2.4</td><td>2.6</td><td>2.8</td>
				</tr>
				<tr>
					<th>6</th>
					<td>1.6666666</td><td>1.8333333</td><td>2</td><td>2.1666666</td><td>2.3333333</td>
				</tr>
				<tr>
					<th>7</th>
					<td>1.4285714</td><td>1.5714285</td><td>1.7142857</td><td>1.8571428</td><td>2</td>
				</tr>
				<tr>
					<th>8</th>
					<td>1.25</td><td>1.375</td><td>1.5</td><td>1.625</td><td>1.75</td>
				</tr>
				<tr>
					<th>9</th>
					<td>1.1111111</td><td>1.2222222</td><td>1.3333333</td><td>1.4444444</td><td>1.5555555</td>
				</tr>
				<tr>
					<th>A</th>
					<td>1</td><td>1.1</td><td>1.2</td><td>1.3</td><td>1.4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>8.4444443^-01</td><td>1</td><td>1.2525252</td><td>1.3434343</td><td>1.4343434</td>
				</tr>
				<tr>
					<th>C</th>
					<td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>1</td><td>1.23</td><td>1.3</td>
				</tr>
				<tr>
					<th>D</th>
					<td>4.^-01</td><td>6.^-01</td><td>8.^-01</td><td>1</td><td>1.2</td>
				</tr>
				<tr>
					<th>E</th>
					<td>5.2929292^-01</td><td>2.2929292^-01</td><td>5.2929292^-0</td><td>8.2929292^-01</td><td>1</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>0.^-01</td><td>1.^-01</td><td>2.^-01</td><td>3.^-01</td><td>4.^-01</td>
				</tr>
				<tr>
					<th>11</th>
					<td>9.090909^-01</td><td>0.^-01</td><td>0.9090909^-01</td><td>1.8181818-01</td><td>2.7272727-01</td>
				</tr>
				<tr>
					<th>12</th>
					<td>8.3333333^-01</td><td>9.1666666^-01</td><td>0.^-01</td><td>0.8333333-01</td><td>1.6666666-01</td>
				</tr>
				<tr>
					<th>13</th>
					<td>7.6923076^-01</td><td>8.4615384^-01</td><td>9.2307692^-01</td><td>0.^-01</td><td>0.7692307-01</td>
				</tr>
				<tr>
					<th>14</th>
					<td>7.1428571^-01</td><td>7.8571428^-01</td><td>8.5714285^-01</td><td>9.2857142-01</td><td>0.^-01</td>
				</tr>
				<tr>
					<th>15</th>
					<td>6.6666666^-01</td><td>7.3333333^-01</td><td>8.^-01</td><td>8.6666666-01</td><td>9.3333333-01</td>
				</tr>
				<tr>
					<th>16</th>
					<td>6.25^-01</td><td>6.875^-01</td><td>7.5^-01</td><td>8.125-01</td><td>8.75-01</td>
				</tr>
				<tr>
					<th>17</th>
					<td>5.8823529^-01</td><td>6.4705882^-01</td><td>7.0588235^-01</td><td>7.6470588-01</td><td>8.2352941-01</td>
				</tr>
				<tr>
					<th>18</th>
					<td>5.5555555^-01</td><td>6.1111111^-01</td><td>6.6666666^-01</td><td>7.2222222-01</td><td>7.7777777-01</td>
				</tr>
				<tr>
					<th>19</th>
					<td>5.2631578^-01</td><td>5.7894736^-01</td><td>6.3157894^-01</td><td>6.8421052-01</td><td>7.368421-01</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>5.^-01</td><td>5.1^-01</td><td>6.3157894-01</td><td>6.1^-01</td><td>7.^-01</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>5.0330001^-01</td><td>6.^-01</td><td>7.0001032-01</td><td>7.8330001-01</td><td>8.2330001-01</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>6.^-01</td><td>7.0003809^-01</td><td>7.8100038-01</td><td>8.1810003-01</td><td>8.100038-01</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>7.0005899^-01</td><td>7.9000589^-01</td><td>8.^-01</td><td>9.0005899-01</td><td>9.9000589-01</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>5.64^-01</td><td>5.90002^-01</td><td>6.4^-01</td><td>6.60002-01</td><td>7.24-01</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>5.4000299^-01</td><td>5.3223099^-01</td><td>6.153223-01</td><td>7.0002999-01</td><td>7.7000299-01</td>
				</tr>
			</table>

<p>
				除了X = 1的情况和一些两位数的情况外，这是对规范化的十六进制数进行普通除法。例如：
				E &divide; 7 = 14 &divide; 7 = 2。
				<br>
				不过，这里也会遇到非规范化的数字
				（例如D &divide; 12，或者C &divide; 11，后者比A &divide; 11小一个数量级）。
				<br>
				也会遇到非规范化的零，例如：C &divide; 12，看起来如下所示：
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-01</span>。
				不过，在<a href="#div_indirect_addr">间接寻址</a>中我们已经遇到过类似的零。
			</p>
		</details>

		<details id="div_hex_y_div_h" open>
			<summary><h4>操作 Y <span class="but">&divide;</span> H</h4></summary>

<table class="trcenter">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>9.090909^-01</td><td>9.9099099^-01</td><td>4.4444443</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>1</th>
					<td>ЕГГ0Г</td><td>9.099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>2</th>
					<td>ЕГГ0Г</td><td>8.4444443^-01</td><td>9.099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>3</th>
					<td>ЕГГ0Г</td><td>6.4444443^-01</td><td>ЕГГ0Г</td><td>9.099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>4</th>
					<td>ЕГГ0Г</td><td>4.4444443^-01</td><td>ЕГГ0Г</td><td>8.^-01</td><td>9.099099^-01</td>
				</tr>
				<tr>
					<th>5</th>
					<td>ЕГГ0Г</td><td>2.4444443^-01</td><td>ЕГГ0Г</td><td>0.^-01</td><td>2.929292^-02</td>
				</tr>
				<tr>
					<th>6</th>
					<td>ЕГГ0Г</td><td>6.4444443^-01</td><td>ЕГГ0Г</td><td>2.^-01</td><td>3.2929292^-01</td>
				</tr>
				<tr>
					<th>7</th>
					<td>ЕГГ0Г</td><td>4.4444443^-01</td><td>ЕГГ0Г</td><td>4.^-01</td><td>6.2929292^-01</td>
				</tr>
				<tr>
					<th>8</th>
					<td>ЕГГ0Г</td><td>2.4444443^-01</td><td>ЕГГ0Г</td><td>0</td><td>9.2929292^-01</td>
				</tr>
				<tr>
					<th>9</th>
					<td>ЕГГ0Г</td><td>0.4444443^-01</td><td>ЕГГ0Г</td><td>2.^-01</td><td>2.2929292^-01</td>
				</tr>
				<tr>
					<th>A</th>
					<td>1</td><td>8.4444443^-01</td><td>ЕГГ0Г</td><td>4.^-01</td><td>5.2929292^-01</td>
				</tr>
				<tr>
					<th>B</th>
					<td>1.1</td><td>1</td><td>ЕГГ0Г</td><td>6.^-01</td><td>2.2929292^-01</td>
				</tr>
				<tr>
					<th>C</th>
					<td>1.2</td><td>1.2525252</td><td>1</td><td>8.^-01</td><td>5.2929292^-01</td>
				</tr>
				<tr>
					<th>D</th>
					<td>1.3</td><td>1.3434343</td><td>1.23</td><td>1</td><td>8.2929292^-01</td>
				</tr>
				<tr>
					<th>E</th>
					<td>1.4</td><td>1.4343434</td><td>1.3</td><td>1.2</td><td>1</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>ЕГГ0Г</td><td>9.09909</td><td>9.9099099</td><td>9.9099099</td><td>9.9099099</td>
				</tr>
				<tr>
					<th>11</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>9.8</td><td>9.0292929</td>
				</tr>
				<tr>
					<th>12</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0</td><td>9.3292929</td>
				</tr>
				<tr>
					<th>13</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0.2</td><td>9.6292929</td>
				</tr>
				<tr>
					<th>14</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0.4</td><td>9.9292929</td>
				</tr>
				<tr>
					<th>15</th>
					<td>ЕГГ0Г</td><td>9</td><td>ЕГГ0Г</td><td>9</td><td>0.22922929</td>
				</tr>
				<tr>
					<th>16</th>
					<td>ЕГГ0Г</td><td>9.2525252</td><td>ЕГГ0Г</td><td>9.2</td><td>0.5292929</td>
				</tr>
				<tr>
					<th>17</th>
					<td>ЕГГ0Г</td><td>9.3434343</td><td>ЕГГ0Г</td><td>9.4</td><td>9.2292929</td>
				</tr>
				<tr>
					<th>18</th>
					<td>ЕГГ0Г</td><td>9.4343434</td><td>ЕГГ0Г</td><td>9.6</td><td>9.5292929</td>
				</tr>
				<tr>
					<th>19</th>
					<td>ЕГГ0Г</td><td>9.5252525</td><td>ЕГГ0Г</td><td>9.8</td><td>9.8292929</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>ЕГГ0Г</td><td>9.6</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>ЕГГ0Г</td><td>9.8525252</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>ЕГГ0Г</td><td>9.9434343</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>ЕГГ0Г</td><td>0.0343434</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>ЕГГ0Г</td><td>7.4444443</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
			</table>


<p>
				这里没有逻辑可言。非常相似但不同的数字：
				9.099099^-01 和 9.9099099^-01（或者 9.099099 和 9.9099099）。
				同样有趣的是，零除以H根本不是零。
				<br>
				最重要的是，这里不仅仅是ЕГГ0Г，而是<strong>坏掉的ЕГГ0Г</strong>，
				这是以前没有遇到过的。在它出现之后，PMK在后续的
				（直到关闭PMK）执行许多操作时
				总是显示ЕГГ0Г。以下是这类操作的列表。
			</p>

<ul>
				<li><span class="but">+</span></li>
				<li><span class="but">-</span></li>
				<li><span class="but">&times;</span></li>
				<li><span class="but">&divide;</span></li>
				<li><span class="but">&lt;-&gt;</span></li>
				<li><span class="but_f">F</span><span class="op_f">sin</span></li>
				<li><span class="but_f">F</span><span class="op_f">cos</span></li>
				<li><span class="but_f">F</span><span class="op_f">tg</span></li>
				<li><span class="but_f">F</span><span class="op_f">&radic;</span></li>
				<li><span class="but_f">F</span><span class="op_f">1/x</span></li>
				<li><span class="but_f">F</span><span class="op_f">sin⁻¹</span></li>
				<li><span class="but_f">F</span><span class="op_f">cos⁻¹</span></li>
				<li><span class="but_f">F</span><span class="op_f">tg⁻¹</span></li>
				<li><span class="but_f">F</span><span class="op_f">&pi;</span></li>
				<li><span class="but_f">F</span><span class="op_f">x&sup2;</span></li>
				<li><span class="but_f">F</span><span class="op_f">eˣ</span></li>
				<li><span class="but_f">F</span><span class="op_f">lg</span></li>
				<li><span class="but_f">F</span><span class="op_f">ln</span></li>
				<li><span class="but_f">F</span><span class="op_f">xʸ</span></li>
				<li><span class="but_f">F</span><span class="op_f">10ˣ</span></li>
				<li><span class="but_f">F</span><span class="op_f">&orarr;</span></li>
			</ul>
<p>
				错误既出现在计算模式中，也出现在程序模式中。有趣的是，
				<span class="but_f">F</span><span class="op_f">&orarr;</span>会产生错误，
				而<span class="but_f">F</span><<span class="op_f">Вx</span>则不会。
			</p>
			<p>
				"蓝色"函数工作正常。显然，这样的ЕГГ0Г只让一个微控制器"发疯"。
			</p>
		</details>

		<details id="div_hex_func" open>
			<summary><h4>对十六进制数进行函数操作的结果</h4></summary>
<table class="trcenter">
				<tr>
					<td><sub>H</sub>&Backslash;<sup>F(H)</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">&radic;</span></td>
					<td>3.1622776</td><td>3.3166247</td><td>3.4641016</td><td>3.6055512</td><td>3.7416573</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td>ЕГГ0Г</td><td>9.099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">eˣ</span></td>
					<td>22026.467</td><td>59874.133</td><td>162754.78</td><td>442413.37</td><td>1202604.3</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td>1.^+10</td><td>1.^+0L</td><td>1.^+0C</td><td>1.^+0Г</td><td>1.^+0E</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">lg</span></td>
					<td>1</td><td>41.823681</td><td>42.40274</td><td>42.816354</td><td>43.126564</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">ln</span></td>
					<td>2.3025851</td><td>96.302585</td><td>97.635918</td><td>98.588299</td><td>99.302585</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&sup1;</span></td>
					<td>10</td><td>6.6631773^+41</td><td>2.5277867^+42</td><td>6.551706^+42</td><td>1.3383338^+43</td>
				</tr>
				<tr>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
			</table>
<ul>
				<li>
					平方的结果与上面提供的乘法表一致。
				</li>
				<li>
					开方完全按照规则进行 &ndash; 就像从规范化数字中开方一样。
				----------</li>
				<li>
					倒数也与除法表一致，而且
					这里再次出现了坏掉的ЕГГ0Г。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">eˣ</span>
					也像开方一样 &ndash; 一切都按照规则。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">10ˣ</span>
					显示十六进制的幂，只是数字A不喜欢亮起来。
				</li>
				<li>对数的结果已经不清楚了。</li>
				<li>
					<span class="but_f">F</span><span class="op_f">x&sup1;</span>
					这是<span class="but_f">F</span><span class="op_f">xʸ</span>，
					对于Y = 1的情况。不过这并没有让结果变得更清楚。
					除了数字A，其他的都像一些
					超级数字一样提升到第一幂。
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span>类似于
					加零。而且，如果数字还有小数部分，
					那么整数部分将保持不变，即使是十六进制的。
				</li>
			</ul>
			<p>
				关于更罕见的度/小时转换操作，请参见
				<a href="#div_command">命令附录</a>。
				包含十六进制值的指数的数字在间接寻址部分
				<a href="#div_indirect_addr_exponent">
					指数包含十六进制数字
				</a>中进行了讨论。
			</p>
		</details>

<details id="div_hex_using" open>
			<summary><h4>实际应用</h4></summary>
			实际应用是指获得非标准结果（与普通数字不同）。或者获得非标准序列。或者就像上面提到的乘法一样。
			<p>
				没有考虑包含两个或更多十六进制数字的情况（包括小数部分），因为这些情况很少见。
				在那里也可以构建类似的表格，但查看特定数字的结果更简单。
			</p>
		</details>
	</details>

	<hr>

	<details id="div_zero_digit" open>
		<summary><h3>用数字代替符号的数字</h3></summary>
		这里讨论的是用数字代替符号的数字。
		在下文中，我们将称其为符号数字。
		作者只知道获取符号数字的方法，其中符号数字来自2...9的范围。此外，有理由认为，除了它们之外，
		只有另外两个数字是允许的：A = 减号，代表负数，以及1，它显示为空位，代表正数。
		对于БЗ-34计算器，可以显示其他数字，但在МК-61中这不起作用。
		<p>
			提醒一下，符号数字在间接寻址中成功“存活”下来。
			请注意，在本节后面的示例中，数字前面的符号数字经常被特别指出。
		</p>
<details id="div_zero_digit_get" open>
			<summary><h4>获取方法</h4></summary>
			<ol>
				<li>
					<strong>0C-反转数的尾巴</strong>。在这种情况下，使用的是Еггогологии的知识。0C-反转数是范围在
					1.^400&hellip;9.9999999^499的数字。
					为了获得这样的数字（更确切地说是"尾巴"），我们将使用程序：
<p>
						<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="code_num">01.</span><span class="but">5</span>&ensp;
						<span class="code_num">02.</span><span class="but">0</span>&ensp;
						<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
						<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="code_num">07.</span><span class="but">&times;</span>&ensp;
						<span class="code_num">08.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
						<span class="code_num">09.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
						<span class="code_num">10.</span><span class="but_b">П&rarr;x</span><span class="reg">c</span>&ensp;
						<span class="code_num">11.</span><span class="but">ВП</span>&ensp;
						<span class="code_num">12.</span><span class="but">7</span>&ensp;
						<span class="code_num">13.</span><span class="but_b">С/П</span>
					</p>

<p>
						输入将传递一个数字（0&hellip;8.9999999]，输出将获得
						来自Rc寄存器的反转数的“尾巴”。因此它们
						被称为0C-反转数，它们自己在屏幕上显示为零，而“尾巴”
						被重置到Rc寄存器。传递九到输入没有意义，因为输出将得到10，更确切地说是数字А，
						即普通的负号。
						<br>
						例如，传递1，我们将得到
						<span class="code">2E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
						传递6，我们将得到
						<span class="code">7E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>，
						等等。按下<span class="but">/-/</span>将获得另一个符号数字
						（很容易计算出是哪一个，因为这样的一对符号数字之和 = 11）。
						顺便说一句，如果尾数为零，那么在<span class="but">/-/</span>
						之后对于任何符号数字都将是-0。
					</p>
					<p>
						这种获取符号数字的方法不是很方便，尤其是因为
						要获得其他数字的尾数需要“费很大劲”，
						例如多次旋转间接地址计数器。
						有更好的方法。
					</p>
				</li>
<li>
					<strong>使用R4&hellip;R6寄存器的间接寻址</strong>。
					关于在使用十六进制数进行R4&hellip;R6的间接寻址时它们的“规范化”已经在
					<a href="#div_indomial_addr_mantissa">
						尾数包含十六进制数字
					</a>中提到过。
					<p>
						所以，如果一个8位数中的第一个数字也是十六进制的，那么
						从高位到符号位的进位就会发生，即
						出现符号数字。
					</p>
					<p>
						首先，我们以普通数字E为例（为简洁起见，
						以非标准方式），稍后将派上用场：
						<span class="but">1</span>&ensp;
						<span class="but_k">К</span><span class="but">-</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="reg">e</span>。
						然后我们将其变为第一个数字（8位数）：
						<span class="but">ВП</span>&ensp;
						<span class="but">7</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="but">4</span>。
						我们得到<span class="code">&nbsp;E0000000.&nbsp;&nbsp;&nbsp;</span>。
						如果现在使用间接增加：
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>，
						那么我们得到<span class="code">240000001.&nbsp;&nbsp;&nbsp;</span>。
						这里数字E的一个单位被转移到符号位。
						与0C-反转数不同，我们目前只得到了两个
						（或者9，如果我们按下<span class="but">/-/</span>）符号数字，但尾数的其他
						数字很容易选择所需的（除了十六进制的，
						它们通过间接寻址规范化），并且可以使用
						<a href="#div_x2_exp_combine">
							恢复X2并用X中的数字替换第一个数字
						</a>
						也可以将第一个数字变为十六进制。
						让我们引入一个简单的程序：
					</p>
					<p>
						<span class="code_num">00.</span><span class="but">&lt;-&gt;</span>&ensp;
						<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
						<span class="code_num">03.</span><span class="but_b">С/П</span>
					</p>
					<p>
						这个程序将X中的数字的第一个数字更改为Y中的第一个
						数字。
						因此，我们取数字E和我们新的带有符号数字2的数字
						并将它们结合起来：
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">В/О</span>&ensp;
						<span class="but_b">С/П</span>。
						我们得到
						<span class="code">2E0000001.&nbsp;&nbsp;&nbsp;</span>。
						如果将这样的数字通过间接寻址：
						<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>，
						那么我们得到<span class="code">34000<pot>
				<li>
					<strong>使用R4&hellip;R6寄存器的间接寻址</strong>。
					关于在使用十六进制数进行R4&hellip;R6的间接寻址时它们的“规范化”已经在
					<a href="#div_indirect_addr_mantissa">
						尾数包含十六进制数字
					</a>中提到过。
					<p>
						因此，如果一个8位数中的第一个数字也是十六进制的，那么
						从高位到符号位的进位就会发生，即
						出现符号数字。
					</p>
					<p>
						首先，我们以普通数字E为例（为简洁起见，
						以非标准方式），稍后将派上用场：
						<span class="but">1</span>&ensp;
						<span class="but_k">К</span><span class="but">-</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="reg">e</span>。
						然后我们将其变为第一个数字（8位数）：
						<span class="but">ВП</span>&ensp;
						<span class="but">7</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="but">4</span>。
						我们得到<span class="code">&nbsp;E0000000.&nbsp;&nbsp;&nbsp;</span>。
						如果现在使用间接增加：
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>，
						那么我们得到<span class="code">240000001.&nbsp;&nbsp;&nbsp;</span>。
						这里数字E的一个单位被转移到符号位。
						与0C-反转数不同，我们目前只得到了两个
						（或者9，如果我们按下<span class="but">/-/</span>）符号数字，但尾数的其他
						数字很容易选择所需的（除了十六进制的，
						它们通过间接寻址规范化），并且可以使用
						<a href="#div_x2_exp_combine">
							恢复X2并用X中的数字替换第一个数字
						</a>
						也可以将第一个数字变为十六进制。
						让我们引入一个简单的程序：
					</p>
					<p>
						<span class="code_num">00.</span><span class="but">&lt;-&gt;</span>&ensp;
						<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
						<span class="code_num">03.</span><span class="but_b">С/П</span>
					</p>
					<p>
						这个程序将X中的数字的第一个数字更改为Y中的第一个
						数字。
						因此，我们取数字E和我们新的带有符号数字2的数字
						并将它们结合起来：
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">В/О</span>&ensp;
						<span class="but_b">С/П</span>。
						我们得到
						<span class="code">2E0000001.&nbsp;&nbsp;&nbsp;</span>。
						如果将这样的数字通过间接寻址：
						<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>，
						那么我们得到<span class="code">340000002.&nbsp;&nbsp;&nbsp;</span>。
						这样也可以得到其他的符号数字
						（直到包括9）。对于那些不喜欢尾部
						（在这个案例中是2）的人来说，他们可以通过使用R0&hellip;R3进行间接寻址将其重置为零。
					</p>
				</li>
			</ol>
		</details>

<details id="div_zero_digit_sign" open>
			<summary><h4>数字的符号是什么？</h4></summary>
			看到这样的数字，首先想到的问题是，它们是正数还是负数？为了表示，
			我们将使用<strong>2</strong>N, <strong>3</strong>N,
			... <strong>9</strong>N，其中明确指出了符号数字，而尾数（可能+指数）用字母N表示。
			<table class="trcenter">
				<tr>
					<td></td>
					<td><strong>2</strong>N</td>
					<td><strong>3</strong>N</td>
					<td><strong>4</strong>N</td>
					<td><<strong>5</strong>N</td>
					<td><strong>6</strong>N</td>
					<td><strong>7</strong>N</td>
					<td><strong>8</strong>N</td>
					<td><strong>9</strong>N</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
					<td>否</td><td>否</td><td>否</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td>是</td><td>是</td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td>
				</tr>
			</table>
			<p>
				如你所见，并非一切都是那么透明。<strong>5</strong>N和
				<strong>6</strong>N可以是负数也可以是正数。
				顺便说一下，与零的比较对所有这些都是正确的（如果
				N不是零，就不是零）。
				<br>
				让我们考虑其他功能，用于间接确定数字的符号。
			</p>
			<ul>
				<li>
					<span class="but_f">F</span><span class="op_f">10ˣ</span>
					仅对<strong>9</strong>N输出正指数。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">1/x</span>
					相反，将<strong>9</strong>N视为负数，其余视为正数。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">eˣ</span>
					也只将<strong>9</strong>N视为负数。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">&radic;</span>
					所有都视为负数，即给出错误。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">lg</span>和
					<span class="but_f">F</span><span class="op_f">ln</span>
					所有都视为负数，即给出错误。
				</я>
				<li>
					<span class="but_f">F</span><span class="op_f">sin</span>
					所有都视为负数，即结果为负。
					其他三角函数的行为类似。
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
					或
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
					将它们视为负数，而
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>
					和 <span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					不改变符号数字。
				</li>
				<li>
					矛盾的是，函数
					<span class="but_f">F</span><span class="op_f">x&sup2;</span>
					对于数字<strong>5</strong>N&hellip;<strong>8</strong>N
					使结果变为负数，尽管按模是正确的。
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">xʸ</span>
					如果数字是基数（即给出错误），则将所有视为负数，但作为指数区分，
					认为<strong>9</strong>N是负数，其余是正数。
				</li>
			</ul>
		</details>

<details id="div_zero_digit_eval" open>
			<summary><h4>这些数字的算术运算</h4></summary>
			需要理解的是，"按模"函数计算是正确的，通常只是结果的符号不明显。
			部分函数已经在上面讨论过了，我们试图确定数字的符号。
			让我们考虑其他的：
			<ul>
				<li>
					<span class="but_k">К</span><span class="op_k">ЗН</span>将尾数替换为1，保留符号数字，即从<strong>8</strong>N，
					得到<strong>8</strong>1。
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&mid;x&mid;</span>
					如预期地丢弃符号数字。
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span>
					保留整数部分并设置负号。
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">{x}</span>，
					如果数字按模&lt; 1<sup>7</sup>（更准确地说，是需要少于八个符号位的数字），则保留小数部分和符号数字。对于较大的数字，符号数字被删除。
				</li>
				<li>
					<span class="but">+</span>在任何组合中都将它们视为负数。
				</li>
				<li>
					<span class="but">-</span>的行为更为狡猾。当带有符号数字的数字是被减数，即位于Y寄存器中时，它的行为就像负数，但是当它是减数（位于X寄存器中）时，
					相反，就像正数。例如，取<strong>6</strong>3
					（6是符号数字），
					那么<strong>6</strong>3 - 1 = -4，
					而1 - <strong>6</strong>3 = -2。
					由此可知，减去两个带有符号数字的数字
					将它们的模相加，但结果保留为负数，
					即行为完全像加法(!)。
				</li>
				<li>
					<span class="but">&times;</span>，<span class="but">&divide;</span>
					处理起来更复杂，需要表格（操作数的顺序不重要）：

<table class="trcenter">
						<tr>
							<td></td>
							<td><strong>+</strong>N</td>
							<td><strong>2</strong>N</td>
							<td><strong>3</strong>N</td>
							<td><strong>4</strong>N</td>
							<td><strong>5</strong>N</td>
							<td><strong>6</strong>N</td>
							<td><strong>7</strong>N</td>
							<td><strong>8</strong>N</td>
							<td><strong>9</strong>N</td>
							<td><strong>-</strong>N</td>
						</tr>
						<tr>
							<td><strong>+</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>2</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>3</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>4</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>5</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>6</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>7</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>8</strong>N</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
						</tr>
						<tr>
							<td><strong>9</strong>N</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
							<td>+</td>
						</tr>
						<tr>
							<td><strong>-</strong>N</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
						</tr>
					</table>
结果至少与函数
					<span class="but_f">F</span><span class="op_f">1/x</span>和
					<span class="but_f">F</span><span class="op_f">x&sup2;</span>
				的行为一致。
				<li>
					<span class="but_k">К</span><span class="op_k">max</span>认为
					具有不同符号数字的数字相等（如果N相同），
					例如对于<strong>8</strong>N和<strong>2</strong>N操作
					不会做任何事情
					（除了将X重置为X1），无论它们处于什么顺序。
					<br>但同时它们都小于<strong>+</strong>N，并且大于
					<strong>-</strong>N。
				</li>
			</ul>
			<p>
				这里需要停下来讨论零。如函数
				<span class="but_k">К</span><span class="op_k">{x}</span>中所述，可能会
				得到一个带有符号数字的零。那么，它的行为就像普通零一样。
				唯一的区别 &ndash; 是在比较函数中。这样的零的行为
				如前所述，适用于带有符号数字的数字。特别是数字
				<span class="code">50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
				对于操作符
				<span class="but_f">F</span><span class="op_f">x&lt;0</span>，
				<span class="but_f">F</span><span class="op_f">x&ge;0</span>，
				<span class="but_f">F</span><span class="op_f">x=0</span>
				将通过，就像满足条件一样。
			</p>
		</details>

<details id="div_zero_digit_sum" open>
			<summary><h4>任意尾数和输出</h4></summary>
			如你所见，几乎所有操作都会销毁符号数字。保证
			可以在不改变符号数字的情况下更改尾数的
			方法是使用间接寻址。当然，尾数也可以提前
			准备好。示例（使用上面获得的程序和数字E）：
			<p>
				<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">В/О</span>&ensp;
				<span class="but_b">С/П</span>
				得到
				<span class="code">&nbsp;E9999998.&nbsp;&nbsp;&nbsp;</span>。
				然后
				<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but_b">В/О</span>&ensp;
				<span class="but_b">С/П</span>.
				实际上，这样几乎可以获得任何需要的尾数
				（除了十六进制的）和相应的符号数字。
			</p>
			<p>
				例如，我们想要获得<strong>3</strong>21，其中3是符号数字。
				使用本节开头提到的简短程序，在数字
				<span class="code">&nbsp;10000019.&nbsp;&nbsp;&nbsp;</span>中，将第一个数字替换为E，得到
				<span class="code">&nbsp;E0000019.&nbsp;&nbsp;&nbsp;</span>。
				经过间接增加后变为
				<span class="code">240000020.&nbsp;&nbsp;&nbsp;</span>。再次替换
				为E，得到
				<span class="code">2E0000020.&nbsp;&nbsp;&nbsp;</span>. 
				再次间接增加将导致

				<span class="code">340000021.&nbsp;&nbsp;&nbsp;</span>。现在，
				将第一个数字替换为零后，剩下
				<span class="code">321.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			</p>
			<p>
				再举一个例子。我想要获得<big>&pi;</big>/2（用于三角函数计算），并且符号数字为九。
				<big>&pi;</big>/2 = 1.5707963。
				从
				<span class="code">&nbsp;15707962.&nbsp;&nbsp;&nbsp;</span>开始，将第一个数字替换为E，得到
				<span class="code">&nbsp;E5707962.&nbsp;&nbsp;&nbsp;</span>。
				经过间接增加后变为
				<span class="code">245707963.&nbsp;&nbsp;&nbsp;</span>。按下
				<span class="but">/-/</span>，得到
				<span class="code">945707963.&nbsp;&nbsp;&nbsp;</span>并进行
				第一个数字替换为1：
				<span class="code">915707963.&nbsp;&nbsp;&nbsp;</span>。剩下只需要
				<span class="but">ВП</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">1</span>，
				我们就得到了我们想要的
				<span class="code">91.5707963&nbsp;&nbsp;&nbsp;</span>。
				可以对其进行三角函数测试，
				比如它的正弦值是-1。
			</p>
			<p>
				实际上，可以得到带有符号数字和十六进制数字的尾数。首先按照开始时提到的
				得到<span class="code">240000001.&nbsp;&nbsp;&nbsp;</span>，然后
				应用以下算法：
			</p>
			<ol>
				<li>通过小程序设置第一个十六进制数字（E来自Re）。</li>
				<li>如果尾数的所有数字已经是十六进制的，则结束。</li>
				<li>
					使用
					<span class="but">ВП</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but">/-/</span>将指数减少一个单位。
				</li>
				<li>
					通过间接寻址在R7&hellip;Rd中获得的结果中删除小数部分。此时，第一个数字的位置将被替换为
					符号数字-1，而我们的十六进制数字将被移位。
					返回第1步。
				</li>
			</ol>
			<p>
				按照这个算法和E数字很容易得到
				<span class="code">2EEEEEEEE.&nbsp;&nbsp;&nbsp;</span>。
			</p>
			<p>
				显然，在算法的第1步中可以输入任何数字
				（除了E）。并且可以从任何符号数字的数字开始。通过这种方式，可以
				获得几乎任何带有
				任何符号数字（除了F或前导零）的尾数。
			</p>
			<p>
				此外，这样的符号数字还会影响其他内容。以
				<a href="#div_x2_exp_SR">
					带丢弃首位的X2恢复
				</a>为例。实际上，上述序列在恢复时
				会在首位写入符号数字-1，这对于正数来说等于零，
				即丢弃该位数字。但如果存在符号数字，
				那么这个序列将在首位写入它的负一而不是首位。
				由此可知，为什么对于负数会写入9，这是负号，
				就像数字A（= 10）减去一。而且符号数字将保留在原位。
			</p>
			<p>
				<strong>实际上</strong>，作者由于在积极使用ПМК的时候并不具备这些知识，
				因此并未使用过这样的数字。
				尽管许多函数对这些数字的非标准行为只是
				基于对数字的反应，但仍然可以
				假设这也可以用于优化。
			</p>
		</details>
	</details>

<hr>

<details id="div_neg_zero_degree" open>
	<summary><h3>具有负零次幂的数字</h3></summary>
	从间接寻址部分我们知道，对于包含十六进制数字的负指数，有“总和 = 160”的规则。当指数降至-160并且根据规则相加得到的不是零次幂，而是负零次幂时，会出现一个有趣的效应。事实证明，具有此类指数的数字也具有不寻常的属性。

<details id="div_nzd_get" open>
	<summary><h4>获取方法</h4></summary>
	如何获得这样一个指数的数字？首先，我们获得一个包含十六进制数字的负指数的数字。例如
	1^.-E0
	（<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-E0</span>）：
	<span class="but">1</span>&ensp;
	<span class="but">0</span>&ensp;
	<span class="but">/-/</span>&ensp;
	<span class="but_k">К</span><span class="but">-</span>&ensp;
	<span class="but">ВП</span>&ensp;
	<span class="but_f">F</span><span class="op_f">10ˣ</span>。
	得到的数字像1.^-140或者根据规则160 = 1.^20。现在
	如果再从指数中去掉20：
	<span class="but">ВП</span>&ensp;
	<span class="but">2</span>&ensp;
	<span class="but">0</span>&ensp;
	<span class="but">/-/</span>&ensp;
	<span class="but_b">x&rarr;П</span><span class="but">1</span>。
	那么我们会得到1.^-00
	（<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-00</span>）。
	<p>
		如果你认为尾数只能是1，那么我会很高兴告诉你，还可以有其他尾数。为了研究具有不同尾数的数字，我们提供一个程序，该程序将R1&hellip;Re寄存器填充为零次负指数的数字，而在第一个数字的位置将放置寄存器的编号（是的，对于最后一个将是E.^-00）。
	</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">3</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">8</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but">ВП</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">1</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but_f">F</span><span class="op_f">L0</span></td>
					<td><span class="but">18</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_b">С/П</span></td>
					<td colspan=9></td>
				</tr>
			</table>

<p>
				这里也使用了未记录的功能。大部分
				（从00到17的地址）是获取（已记录的）与我们手动做的相同的1^.-00，只是没有ЕГГ0Г。而且不是通过E0，而是通过L0
				（只是数字13需要用于剩余寄存器R2&hellip;Re的循环）。由于<span class="but">ВП</span>在程序模式下的行为特点，需要将X复制到X2。第一次我们通过
				<span class="but">/-/</span>在地址08处得到帮助，第二次我们明确地做<span class="but">В&uarr;</span>在地址12处。但从18号地址开始就是
				"萨满教"。程序片段18&hellip;21增加当前数字
				（以十六进制意义上）。这个特性在关于X2寄存器和<span class="but">ВП</span>命令的部分中已经讲述。而片段
				22&hellip;25（同一部分）将这个数字放入R1中的数字。
				然后我们使用Re寄存器将其保存在需要的位置并重复。
			</p>
			<p>
				我们将这种具有不寻常指数的数字表示为N。一般来说，
				零次幂（即使是负的）在数学意义上不会改变任何东西，
				即数字应该好像没有指数一样。并且大多数操作确实是这样
				感知它的，但也有例外。让我们遍历所有的
				操作/函数，使用上述程序输入寄存器的值。
			</p>
		</details>

<details id="div_nzd_plus" open>
			<summary><h4>加法和减法</h4></summary>
			这里操作数的顺序不重要。规则是这样的：如果第二个操作数的整数部分只由一个数字组成（这里也包括十六进制数字，小数部分可以是任何数），那么这个操作数（即整个数字）首先乘以10（对十六进制数字也是如此），然后执行与N的操作。示例：
			<br>
			2.^-00 + 5.1 = 53:
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">5</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but">+</span> =
			<span class="code">&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			<br>
			2.1 - 3.^-00 = 18:
			<span class="but">2</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
			<span class="but">-</span> =
			<span class="code">&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			<br>
			<big>&pi;</big> - 3.^-00 = 28.415926;
			<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
			<span class="but">-</span> =
			<span class="code">&nbsp;28.415926&nbsp;&nbsp;&nbsp;</span>。
			<br>
			E.1 + 2^.-00 = 43:
			<span class="but">1</span>&ensp;
			<span class="but">.</span>&ensp;
			<span classación="but">1</span>&ensp;
			<span class="but_k">К</span><span class="but">-</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">+</span> =
			<span class="code">&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			<p>
				对于两个或更多位数的操作数，执行常规操作。示例：
				<br>
				2.^-00 + 51 = 53:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				<br>
				21 - 3.^-00 = 18:
				<span class="but">2</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				<br>
				e<sup>&pi;</sup> - 3.^-00 = 20.14069:
				<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="but_f">F</span><span class="op_f">eˣ</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">&nbsp;20.14069&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				<br>
				E1 + 2^.-00 = 43:
				<span class="but">1</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			<p>
				如果分数（整数部分为零），则执行常规操作。示例：
				<br>
				0.5 + 4.^-00 = 4.5:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;4.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				<br>
				E.1^-01 + 4.^-00 = 5.41:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;5.41&nbsp;&nbsp;&nbsp;&&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			</p>

<p>
				数字N本身不遵循乘以10的规则，而是像往常一样执行。
				<br>
				5^.-00 + 2.^-00 = 7:
				<span class="but_b">П&rarr;x</span><span class="but">5</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				<br>
				2^.-00 - 3.^-00 = -1:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">-1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			</p>
			<p>
				如果第二个操作数是零，也像往常一样工作。
				<br>
				9.^-00 + 0 = 9:
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
				对比：
				<br>
				9.^-00 + 1 = 9:
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			</p>
		</details>

<details id="div_nzd_mult" open>
			<summary><h4>乘法和除法</h4></summary>
			在进行<strong>乘法</strong>时，如果数字N在操作前位于Y寄存器中，而X寄存器中的数字小于1（绝对值），那么得到的数字将是-160次幂，即数字N在操作中被视为-160次幂的数字（顺便说一下，考虑到ПМК的循环性，可以将其视为840次幂的数字）。在其他情况下，就像普通的乘法一样进行。示例：
			<br>
			1.5 &times; 2^.-00 = 3:
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">5</span>&ensp;
			<span class="but">&times;</span> =
			<span class="code">&nbsp;3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			<br>
			0.7 &times; 2^.-00 = 1.4^-160:
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">0</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">7</span>&ensp;
			<span class="but">&times;</span> =
			<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			看似零，但这是因为在规范化如此高次幂的数字时，它们被转换为零。为了验证，我们可以编写一个程序，将得到的数字乘以1^.80：
			<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="code_num">02.</span><span class="but">0</span>&ensp;
			<span class="code_num">03.</span><span class="but">.</span>&ensp;
			<span class="code_num">04.</span><span class="but">7</span>&ensp;
			<span class="code_num">05.</span><span class="but">&times;</span>&ensp;
			<span class="code_num">06.</span><span class="but">8</span>&ensp;
			<span class="code_num">07.</span><span class="but">0</span>&ensp;
			<span class="code_num">08.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
			<span class="code_num">09.</span><span class="but">&times;</span>&ensp;
			<span class="code_num">10.</span><span class="but_b">С/П</span>
			<br>
			在<span class="but_b">В/0</span>&ensp;
			<span class="but_b">С/П</span>之后，屏幕上将显示
			<span class="code">&nbsp;1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-80</span>
			<p>
				如果X中的数字大于1，但其指数不小于60，则数字N再次被视为-160次幂的数字。
				<br>

1.^62 &times; 7^.-00 = 7.^-98:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">6</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-98</span>.
				<br>
				1.^60 &times; 7^.-00 = 7.^-100:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">6</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				-1.^99 &times; 7^.-00 = -7.^-61:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">-7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-61</span>.
			</p>

<p>
				如果X中的数字小于1，但其指数小于-40，则乘法再次像往常一样进行：
				<br>
1.^-43 &times; 6^.-00 = 6.^-43:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-43</span>.
				<br>
				1.^-40 &times; 6^.-00 = 6.^-200:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				-1.^-99 &times; 6^.-00 = -6.^-99:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">-6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-99</span>.
			</p>

<p>
				提醒一下，如果数字N位于X寄存器中，则进行正常的乘法，但如果Y中也包含N（可能是不同的），则结果将是上述的-160次幂。
				<br>

3^.-00 &times; 7^.-00 = 2.1^-159:
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				为了检查
				<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="code_num">02.</span><span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="code_num">03.</span><span class="but">&times;</span>&ensp;
				<span class="code_num">04.</span><span class="but">8</span>&ensp;
				<span class="code_num">05.</span><span class="but">0</span>&ensp;
				<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="code_num">07.</span><span class="but">&times;</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span> =
				<span class="code">&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-79</span>.
			</p>

<p>
				对于<strong>除法</strong>，情况类似。不寻常的现象只出现在
				除以N（N在X寄存器中）时。如果Y寄存器中的数字按模在
				1 &les; Y &lt; 10的范围内（这里也包括十六进制数字），
				那么在除法操作中N表现为-160次幂的数字。
				<br>
8^.-00 &divide; 2 = 4:
				<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				18 &divide; 2^.-00 = 9:
				<span class="but">1</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				0.8 &divide; 2^.-00 = 0.4:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-01</span>.
				<br>
				8 &divide; 2^.-00 = 4^.160:
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;ЕГГ0Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>

为了检查，我们将编写一个程序：
				<small>00.</small><span class="but_cx">Сx</span>&ensp;
				<small>01.</small><span class="but">8</span>&ensp;
				<small>02.</small><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<small>03.</small><span class="but">&divide;</span>&ensp;
				<small>04.</small><span class="but">7</span>&ensp;
				<small>05.</small><span class="but">0</span>&ensp;
				<small>06.</small><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<small>07.</small><span class="but">&divide;</span>&ensp;
				<small>08.</small><span class="but_b">С/П</span>
				<br>
				在<span class="but_b">В/0</span>&ensp;
				<span class="but_b">С/П</span>之后，屏幕上将显示
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90</span>。
			<p>
				唯一的例外是当Y中也包含数字N时。那么
				除法再次像往常一样进行。
				<br>
				8^.-00 &divide; 2^.-00 = 4:
				<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
			</p>
		</details>

<details id="div_nzd_func_F" open>
			<summary><h4>“黄色”函数</h4></summary>
			“黄色”函数 - 通过按钮
			<span class="but_f">F</span>调用的函数。
			<ul>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">&radic;</span>。
						取根时像往常一样计算，但结果除以
						10<sup>48</sup>，即数字的指数将是-48。示例：
						<br>
						&radic;(4.^-00) = 2.^-48:
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_f">F</span><span class="op_f">&radic;</span> =
						<span class="code">&nbsp;2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-48</span>。
						<br>
						&radic;(E.^-00) = 3.7416573^-48:
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_f">F</span><span class="op_f">&radic;</span> =
						<span class="code">&nbsp;3.7416573-48</span>。
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">1/x</span>。
						倒数计算将数字N视为-160次幂的数字。
						<br>
						1 / (2^.-00) = 5.^159:
						<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_f">F</span><span class="op_f">1/x</span> =
						<span class="code">&nbsp;ЕГГ0Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
						<br>
						为了验证，我们编写一个程序：
						<span class="code_num">00.</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="code_num">01.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
						<span class="code_num">02.</span><span class="but">7</span>&ensp;
						<span class="code_num">03.</span><span class="but">0</span>&ensp;
						<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
						<span class="code_num">05.</span><span class="but">&divide;</span>&ensp;
						<span class="code_num">06.</span><span class="but_b">С/П</span>
						<br>
						在<span class="but_b">В/0</span>&ensp;
						<span class="but_b">С/П</span>之后，屏幕上将显示
						<span class="code">&nbsp;5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89</span>。
					</p>
				</li>
				<li>
					<p>
						我们只在几个值上考虑三角函数。
					</p>
					<p>
						对于<span class="but_f">F</span><span class="op_f">sin</span>，只有在弧度制下才有区别：
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>8.4147098^-01</td>
							<td>1.5707317^-02</td>
							<td>1.7452405^-02</td>
						</tr>
						<tr>
							<th>1</th>
							<td>8.4147103^-01</td>
							<td>1.5707317^-02</td>
							<td>1.7452405^-02</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						对于<span class="but_f">F</span><span class="op_f">cos</span>也是：
					</p>

<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>2.^-00</th>
							<td>4.4721363^-01</td>
							<td>9.9950656^-01</td>
							<td>9.9939082^-01</td>
						</tr>
						<tr>
							<th>2</th>
							<td>-4.1614688^-01</td>
							<td>9.9950656^-01</td>
							<td>9.9939082^-01</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						对于<span class="but_f">F</span><span class="op_f">tg</span>也是：
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>3.^-00</th>
							<td>3</td>
							<td>4.7158802^-02</td>
							<td>5.2407778^-02</td>
						</tr>
						<tr>
							<th>3</th>
							<td>-1.4254648^-01</td>
							<td>4.7158802^-02</td>
							<td>5.2407778^-02</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						对于<span class="but_f">F</span><span class="op_f">sin⁻¹</span>，所有的都不同：
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>7.853981^-01</td>
							<td>50.000003</td>
							<td>45.000002</td>
						</tr>
						<tr>
							<th>1</th>
							<td>1.5707963</td>
							<td>100</td>
							<td>90</td>
						</tr>
						<tr>
							<th>2.^-00</th>
							<td>1.1071486</td>
							<td>70.483276</td>
							<td>63.434949</td>
						</tr>
						<tr>
							<th>2</th>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						对于<span class="but_f">F</span><span class="op_f">cos⁻¹</span>，所有的都不同：
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>7.8539812^-01</td>
							<td>49.999997</td>
							<td>44.999998</td>
						</tr>
						<tr>
							<th>1</th>
							<td>0</td>
							<td>00</td>
							<td>00</td>
						</tr>
						<tr>
							<th>2.^-00</th>
							<td>4.6364761^-01</td>
							<td>29.516724</td>
							<td>26.565051</td>
						</tr>
						<tr>
							<th>2</th>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">tg⁻¹</span>
						对于数字N总是给出零：
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>0</td>
							<td>0</td>
							<td>00</td>
						</tr>
						<tr>
							<th>1</th>
							<td>7.853981^-01</td>
							<td>50.000003</td>
							<td>45.000002</td>
						</tr>
						<tr>
							<td colspan=4></td>
						</tr>
						<tr>
							<th>8.^-00</th>
							<td>0</td>
							<td>0</td>
							<td>00</td>
						</tr>
						<tr>
							<th>8</th>
							<td>1.4464413</td>
							<td>92.083315</td>
							<td>82.874983</td>
						</tr>
					</table>
				</li>


<li>
					<p>
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>
						像往常一样计算，但此时数字的指数减少160。
						规范化后得到零：
						<br>
2^.00&sup2; = 4^.-160:
						<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>
						даёт <span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
						<br>
						8^.00&sup2; = 6.4^-159:
						<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>
						给出 <span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
						<br>
						但一个小检查显示了真实情况:
						<small>00.</small><span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
						<small>01.</small><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<small>02.</small><span class="but">7</span>&ensp;
						<small>03.</small><span class="but">0</span>&ensp;
						<small>04.</small><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
						<small>05.</small><span class="but">&times;</span>&ensp;
						<small>06.</small><span class="but_b">С/П</span>
						<br>
						在<span class="but_b">В/0</span>&ensp;
<span class="but_b">С/П</span>之后，屏幕上将显示
						<span class="code">&nbsp;6.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-89</span>.
					</p>
				</li>
<li>
					<p>
						<span class="but_f">F</span><span class="op_f">eˣ</span>
						像往常一样计算。
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">lg</span>
						输出如下：
					</p>
<table class="trcenter">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">lg</span></td>
						</tr>
						<tr>
							<th>1^.-00</th>
							<td>0</td>
						</tr>
						<tr>
							<th>2^.-00</th>
							<td>-43.128418</td>
						</tr>
						<tr>
							<th>3^.-00</th>
							<td>-42.952326</td>
						</tr>
						<tr>
							<th>4^.-00</th>
							<td>-42.827388</td>
						</tr>
						<tr>
							<th>5^.-00</th>
							<td>-42.730478</td>
						</tr>
						<tr>
							<th>6^.-00</th>
							<td>-42.651297</td>
						</tr>
						<tr>
							<th>7^.-00</th>
							<td>-42.58435</td>
						</tr>
						<tr>
							<th>8^.-00</th>
							<td>-42.526358</td>
						</tr>
						<tr>
							<th>9^.-00</th>
							<td>-42.475205</td>
						</tr>
						<tr>
							<th>A^.-00</th>
							<td>-42.429448</td>
						</tr>
						<tr>
							<th>B^.-00</th>
							<td>-1.6057671</td>
						</tr>
						<tr>
							<th>C^.-00</th>
							<td>-1.0267076</td>
						</tr>
						<tr>
							<th>D^.-00</th>
							<td>-6.1309386^-01</td>
						</tr>
						<tr>
							<th>E^.-00</th>
							<td>-3.0288357^-01</td>
						</tr>
					</table>
				</li>

<li>
					<p>
						<span class="but_f">F</span><span class="op_f">ln</span>
						也是从B.^-00开始给出不同的指数：
					</p>


<table class="trcenter">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">ln</span></td>
						</tr>
						<tr>
							<th>1^.-00</th>
							<td>0</td>
						</tr>
						<tr>
							<th>2^.-00</th>
							<td>-99.306853</td>
						</tr>
						<tr>
							<th>3^.-00</th>
							<td>-98.901388</td>
						</tr>
						<tr>
							<th>4^.-00</th>
							<td>-98.613706</td>
						</tr>
						<tr>
							<th>5^.-00</th>
							<td>-98.390562</td>
						</tr>
						<tr>
							<th>6^.-00</th>
							<td>-98.208241</td>
						</tr>
						<tr>
							<th>7^.-00</th>
							<td>-98.05409</td>
						</tr>
						<tr>
							<th>8^.-00</th>
							<td>-97.920559</td>
						</tr>
						<tr>
							<th>9^.-00</th>
							<td>-97.802776</td>
						</tr>
						<tr>
							<th>A^.-00</th>
							<td>-97.697415</td>
						</tr>
						<tr>
							<th>B^.-00</th>
							<td>-3.6974155</td>
						</tr>
						<tr>
							<th>C^.-00</th>
							<td>-2.3640818</td>
						</tr>
						<tr>
							<th>D^.-00</th>
							<td>-1.4117008</td>
						</tr>
						<tr>
							<th>E^.-00</th>
							<td>-6.974152 ^-01</td>
						</tr>
					</table>
				</li>
<li>
					<p>
						<span class="but_f">F</span><span class="op_f">10ˣ</span>
并不因为溢出而报错，而是像往常一样：指数超出范围。尽管作为幂运算结果的负数值当然令人惊讶。
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
						</tr>
						<tr>
							<th>1^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>2^.-00</th>
							<td>-13.02585</td>
						</tr>
						<tr>
							<th>3^.-00</th>
							<td>-36.051703</td>
						</tr>
						<tr>
							<th>4^.-00</th>
							<td>-59.077562</td>
						</tr>
						<tr>
							<th>5^.-00</th>
							<td>-7.0398713</td>
						</tr>
						<tr>
							<th>6^.-00</th>
							<td>-6.4318666</td>
						</tr>
						<tr>
							<th>7^.-00</th>
							<td>-5.5095304</td>
						</tr>
						<tr>
							<th>8^.-00</th>
							<td>-3.9441377</td>
						</tr>
						<tr>
							<th>9^.-00</th>
							<td>-7.0326326^-01</td>
						</tr>
						<tr>
							<th>A^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>B^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>C^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>D^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>E^.-00</th>
							<td>1</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">xʸ</span>
						行为也不标准。
如果数字N是指数，即在Y寄存器中，那么只有当X中的数字不小于数字e（指数）时，它才能正常工作，否则给出单位。
					</p>
					<table class="trcenter">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
							<td>1.^-00</td><td>1</td><td>2.^-00</td><td>2</td><td>3^.-00</td><td>3</td>
						</tr>
						<tr>
							<td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
						</tr>
						<tr>
							<td>2</td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td><td>7.9999993</td>
						</tr>
						<tr>
							<td>2.7182817</td>
							<td>1</td><td>2.7182817</td>
							<td>1</td><td>7.3890551</td>
							<td>1</td><td>20.085531</td>
						</tr>
						<tr>
							<td>2.7182818</td>
							<td>2.7182818</td><td>2.7182818</td>
							<td>7.3890557</td><td>7.3890557</td>
							<td>20.085535</td><td>20.085535</td>
						</tr>
						<tr>
							<td>3</td>
							<td>2.9999994</td><td>2.9999994</td>
							<td>8.9999984</td><td>8.9999984</td>
							<td>26.999992</td><td>26.999992</td>
						</tr>
					</table>
					<p>
						如果N是底数，即在X寄存器中，那么情况就不那么乐观了。
<br>
1.^-00像往常一样工作，即在任何指数下都给出单位。
<br>
2^.-00很快就会变成错误：
					</p>
					<table class="trcenter">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
							<td>2</td><td>2.29</td><td>2.30</td><td>2.31</td><td>2.32</td>
						</tr>
						<tr>
							<td>2.^-00</td>
							<td>5.5355546^-87</td>
							<td>1.7215634^-99</td>
							<td>0(=6.3773317^-100)</td>
							<td>ЕГГ0Г(=2.3624032^-100)</td>
							<td>ЕГГ0Г(просто ошибка аргумента)</td>
						</tr>
					</table>
					<p>
						对于其他基数和指数，除了指数1之外，都会报错。
并且再次从B^.-00开始改变级别。
					</p>
					<table class="trcenter">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
							<td>1</td>
						</tr>
						<tr>
							<td>2.^-00</td><td>7.4401479^-44</td>
						</tr>
						<tr>
							<td>3.^-00</td><td>1.1160242^-43</td>
						</tr>
						<tr>
							<td>4.^-00</td><td>1.4880297^-43</td>
						</tr>
						<tr>
							<td>5.^-00</td><td>1.8600371^-43</td>
						</tr>
						<tr>
							<td>6.^-00</td><td>2.2320432^-43</td>
						</tr>
						<tr>
							<td>7.^-00</td><td>2.6040517^-43</td>
						</tr>
						<tr>
							<td>8.^-00</td><td>2.9760592^-43</td>
						</tr>
						<tr>
							<td>9.^-00</td><td>3.3480707^-43</td>
						</tr>
						<tr>
							<td>A.^-00</td><td>3.7200738^-43</td>
						</tr>
						<tr>
							<td>B.^-00</td><td>2.478751^-02</td>
						</tr>
						<tr>
							<td>C.^-00</td><td>9.4035621^-02</td>
						</tr>
						<tr>
							<td>D.^-00</td><td>2.437284^-01</td>
						</tr>
						<tr>
							<td>E.^-00</td><td>4.9787053^-01</td>
						</tr>
					</table>
				</li>
			</ul>
		</details>

<details id="div_nzd_func_K" open>
			<summary><h4>"蓝色"函数</h4></summary>
			"蓝色"函数 - 通过按钮
			<span class="but_k">К</span>调用的函数。
			<ul>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">[x]</span>
						将数字N视为分数，并输出零。
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">{x}</span>
						同样认为它们是分数，因此不改变它们，即使是十六进制的。
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">max</span>
						像往常一样工作，例如，它认为数字8和8^.-00是相等的。
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">|x|</span>
						也像往常一样工作，即如果是负数，则去掉负号，但不改变尾数和指数。
					</<p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">ЗН</span>
						也像往常一样工作，即给出±1。
					</p>
				</li>
				<li>
					<p>
						一组函数
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>、
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>、
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>、
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>，
						这些函数通常很少使用，在这里有助于扩展数字N的尾数范围。问题在于，它们也将这些数字视为分数，但与其他函数不同的是，在处理时不改变指数。这意味着数字仍然保持零负指数（当然，如果结果不是降低指数的情况下）。例如：
						<br>
						<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>
						将输出
						<span class="code">&nbsp;2.9999999-00</span>，如果稍作更改：
						<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>，
						那么已经是<span class="code">&nbsp;2.9945599-00</span>
						<br>
						或者
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but">/-/</span>
						将给出<span class="code">--.16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-00</span>。
					</p>
					<p>
						显然，这样一组尾数是有限的，但仍然允许丰富数字N的集合。
					</p>
				</li>
				<li>
					<p>
						逻辑函数，像往常一样，根本不考虑指数，做它们通常的工作，去除所有不必要的。
					</p>
				</li>
			</ul>
		</details>

<details id="div_nzd_sum" open>
    <summary><h4>总结</h4></summary>
    在实践中，这样的数字可以通过它们的双重性在执行计算时被使用。也就是说，在正常情况下作为普通常数，但在某些条件下突然改变其行为。主要是乘法和除法，即使出现具有较大负阶的数字，实际上任何影响X2的命令都会立即将它们变成普通的零。
</details>
</details>

<hr>

<details id="div_tricks" open>
    <summary><h3>优化技巧</h3></summary>
    这里介绍了一些优化程序的方法。大多数技巧是利用已记录的功能，但可能以不寻常的方式使用。
    显然，无法考虑所有变体，只介绍几个以演示如何非标准地解决优化问题。
    <ul>
        <li>
            <strong>间接寻址代替直接寻址。</strong>这是一个显而易见的解决方案，因为（无）条件跳转（或调用子程序）占用两个命令，而使用间接寻址只需一个命令。这样的调用越多，就越有利。
            <p></p>
        </li>
        <li>
            <strong>栈的正确顺序。</strong>这也是一个显而易见的解决方案，在这种解决方案中，改变计算顺序以使操作数尽可能多地使用栈（而不是内存寄存器），并且按照后续计算的顺序排列。或者 - 使用计算栈来复制数字。假设需要在计算中多次使用某个数字。为了避免多次从内存寄存器中调用它（甚至可能不需要保存），可以使用以下方法：在需要之前先计算数字，然后在其后进行其他计算，但要确保我们的数字“到达”T寄存器。然后完成其他计算，而Y...T寄存器保持填充我们的数字（并且以后还会继续填充）。这样可以节省从寄存器调用的命令。
            <p></p>
        </li>
        <li>
            <strong>使用间接寻址空间的旁支。</strong>这些方法已在前面关于<a href="#div_addr_space">地址空间</a>的部分中讨论过。
            <p></p>
        </li>
        <li>
            <strong>将<span class="but_b">БП</span>&ensp;
            <span class="but">01</span>替换为<span class="but_b">В/О</span>。</strong>这只有在返回地址栈为空（零）时才有效。请参阅<a href="#div_command">附录</a>中关于<span class="but_b">В/О</span>命令的注释。
            <p></p>
        </li>
        <li>
            <strong>合并跳转地址和命令。</strong>在这种情况下，双字命令（通常是<span class="but_b">БП</span>）的跳转地址同时用作另一个序列的普通命令。显然，需要知道操作码。由于间接寻址的分支或其不确定性，可以将地址“调整”为需要的命令。例如，序列<span class="but_b">БП</span>&ensp;
            <span class="but">53</span>&ensp;
            <span class="but_b">x&rarr;П</span><span class="reg">d</span>可以替换为
            <span class="but_b">БП</span>&ensp;
            <span class="but">4D</span>，
            因为地址4D = 53，而4D =<span class="but_b">x&rarr;П</span><span class="reg">d</span>。
            <p>
                有时为了这种“调整”，会对程序进行重构：混合独立的程序块，将它们放置在不同的地址。这里还涉及到一篇来自杂志
                <a href="http://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1985-09--num50" target="_blank">
                  ТМ &numero;9 1985年9月：
                </a>
            </p>
            <p>
                <span class="code_num">60.</span><span class="but_f">F</span><span class="op_f">x&lt;0</span>&ensp;
                <span class="code_num">61.</span><span class="but">61</span>&ensp;
                <span class="code_num">62.</span><span class="but_f">F</span><span class="op_f">x&ge;0</span>&ensp;
                <span class="code_num">63.</span><span class="but">63</span>&ensp;
                <span class="code_num">64.</span><span class="but_b">С/П</span>
            </p>
            在停止前输出所需寄存器的内容时进行检查。这样可以节省跳转地址与从寄存器提取命令相一致的地址。
            <p></p>
        </li>
        <li>
            <strong>删除条件运算符。</strong>这里说的是将通常为双重的条件运算符替换为简单的算术运算。假设有一个程序部分，在X &ne; 0时需要向R9寄存器添加一（某种计数器）。直接解决方案：
            <p>
                <span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>&ensp;
                <span class="code_num">01.</span><span class="but">06</span>&ensp;
                <span class="code_num">02.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
                <span class="code_num">03.</span><span class="but">1</span>&ensp;
                <span class="code_num">04.</span><span class="but">+</span>&ensp;
                <span class="code_num">05.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
            </p>
            删除条件的解决方案：
            <p>
                <span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">ЗН</span>&ensp;
                <span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
                <span class="code_num">02.</span><span class="but">+</span>&ensp;
                <span class="code_num">03.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
            </p>
            如果X可能为负数，解决方案会稍长一些，但仍然比直接解决方案短：
            <p>
                <span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">ЗН</span>&ensp;
                <span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">|x|</span>&ensp;
                <span class="code_num">02.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
                <span class="code_num">03.</span><span class="but">+</span>&ensp;
                <span class="code_num">04.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
            </p>
        </li>
        <li>
            <strong>非标准使用FLx循环。</strong>
            <ol>
                <li>
                    知道循环结束后会留下1，可以在重复进入时不初始化它。
                </li>
                <li>
                    快速检查R0...R3寄存器的内容是否为1，如果不满足则跳转。有时为了这个可能性，会特意使用R0...R4而不是其他寄存器。
                </li>
                <li>
                    执行与循环无关的操作。例如，在某个子程序结束时需要减少R2寄存器中的尝试次数计数器并跳转到地址（假设为77）。与其这样做
                    <p>
                        <span class="code_num">00.</span><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
                        <span class="code_num">01.</span><span class="but_b">БП</span>&ensp;
                        <span class="code_num">02.</span><span class="but">77</span>
                    </p>
                    这实际上会破坏堆栈（并且可能需要另一个命令来修复），不如这样做：
                    <p>
                        <span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">L2</span>&ensp;
                        <span class="code_num">01.</span><span class="but">77</span>
                    </p>
                    当然，计数器不能结束，或者在此代码之后立即进行检查。如果对“无限”的计数器，有时会将其设置为负数，如果在计算结束时重要的是开始和结束之间的差异。
                </li>
            </ol>
            <p></p>
        </li>
        <li>
            <strong>检查大于/小于1。</strong>如果已知数字不是负数，则可以立即取<span class="but_f">F</span><span class="op_f">lg</span>并检查大于/小于零。
            <p></p>
        </li>
        <li>
            <strong>在条件下因错误而停止。</strong>以下是一些生成错误并在不检查条件的情况下停止的方法：
            <ol>
                <li>
                    如果零 - <span class="but_f">F</span><span class="op_f">1/x</span>
                </li>
                <li>
                    如果小于或等于零 - <span class="but_f">F</span><span class="op_f">lg</span>
                </li>
                <li>
                    如果小于零 - <span class="but_f">F</span><span class="op_f">&radic;</span>
                </li>
                <li>
                    如果大于1 - <span class="but_f">F</span><span class="op_f">cos⁻¹</span>或<span class="but_f">F</span><span class="op_f">sin⁻¹</span>
                </li>
                <li>
                    如果大于或等于100 - <span class="but_f">F</span><span class="op_f">10ˣ</span>
                </li>
                <li>
                    如果小数部分大于或等于0.6 - <span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
                </li>
            </ol>
            <p></p>
        </li>
        <li>
            <strong>调用子程序的一部分。</strong>例如，假设有一个算法，它以特殊方式处理数字，但只处理整数或小数部分。需要使其更加通用，即适用于任何数字。可以这样做：
            <p>
                <span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
                <span class="code_num">01.</span><span class="but">0</span>&ensp;
                <span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">Вx</span>&ensp;
                <span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">[x]</span>&ensp;
                <span class="code_num">04.</span><span class="but_b">ПП</span>&ensp;
                <span class="code_num">05.</span><span class="but">07</span>&ensp;
                <span class="code_num">06.</span><span class="but">&lt;-&gt;</span>&ensp;
                <span class="code_num">07.</span>&hellip;&ensp;
                <span class="code_num">20.</span><span class="but">+</span>&ensp;
                <span class="code_num">21.</span><span class="but_b">В/О</span>
            </p>
            这里发生了什么？首先为未来的小数部分做准备，然后推入零并保留整数部分。接下来调用代码的一部分（当前子程序的一部分），该部分对整数部分进行处理，最后进行加法（在这种情况下为零）。然后整数和小数部分交换位置，代码重复，但在最后进行加法以实现合并，然后返回。节省在哪里？如果我们依次调用处理部分，那么我们仍然需要对整数和小数部分进行分割，依次处理，然后通过加法合并。为此，我们需要所有相同的命令，除了<span class="but">0</span>。但这样做需要两次<span class="but_b">ПП</span>，这是两个命令。通过替换为一个命令<span class="but">0</span>并调用自己的“尾巴”，我们节省了一个命令。
            <p></p>
        </li>
        <li>
            <strong>合并常量和跳转地址。</strong>在这种情况下，讨论的是某个用于计算的常量同时包含跳转地址。有时人们故意这样做，将程序移动到常量的值下，有时则可以合并。作者实践中的一个例子 - 对于玩家的位位置，使用了N.0000H格式，其中N - 某个“楼层”，H - 位（数字1、2、4或8），小数部分的零的数量决定了在“楼层”上的位置。通过乘以/除以二（位）和乘以/除以十（在楼层上左右移动）来执行“楼层”上的移动。潜在的问题 - 在不同阶数的数字相加时自动舍入产生的PMK。在这种情况下，当小数部分= 0.000000H（H.^-07）并且除以10时，得到的数字“超出楼层”，H.^-08，应该被清零。对于H = 1、2、4，在与整数相加时确实如此，但如果H = 8，则会发生异常：在舍入结果中，8.^-08变成了1.^-07（意外的传送）。为了使程序正确运行，在相加之前需要从获得的数字中减去一个范围在3.^-08 &les; X &lt; 5.^-08的值，这样就不会破坏H = 1、2、4的情况，并且可以使H = 8的数字在舍入时被清零。所以，使用<a href="#div_indirect_addr">间接寻址</a>的知识，可以向3.^-08（或4.^-08）添加几个数字。这对修正舍入没有影响，但允许将这些数字用作跳转地址。假设需要一个间接寻址地址为77，那么常量将是3.77^.-08。如果考虑到间接寻址不会被规范化，那么它也被用于显示特殊情况： <span class="code">&nbsp;0.0000377-03</span>。
        </li>
    </ul>
</details>

<hr>

<details id="div_demo" open>
    <summary><h3>演示程序</h3></summary>
    <details id="div_demo_preface" open>
        <summary><h4>程序界面描述</h4></summary>
        作为演示，使用了在杂志《<a href="http://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1987-07--num42" target="_blank">青年技术</a>》1987年第7期发表的“宝藏洞穴”程序的<strong>修改版</strong>。
        <p>
            对于不想点击链接（或查看扫描的小字体）的人，我们来描述一下游戏。这是一个三维迷宫（共3层，每层7×4的大小），其中每个单元格可以是空的，也可以是占用的 - “墙”。游戏的目标是 - 从迷宫的某个初始点开始，穿过整个迷宫（在第三层左下角的出口 - 向左），并收集尽可能多的宝藏。
            为了理解地址定位，这里是杂志中第一层的平面图：
        </p>
        <table>
            <tr>
                <td></td><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th>
            </tr>
            <tr>
                <th>1</th>
                <td>&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
            </tr>
            <tr>
                <th>2</th>
                <td>&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td>&emsp;</td>
                <td>&emsp;</td>
                <td>&emsp;</td>
                <td>&emsp;</td>
                <td class="wall_color">&emsp;</td>
            </tr>
            <tr>
                <th>4</th>
                <td>&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td>&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td>&emsp;</td>
                <td>&emsp;</td>
            </tr>
            <tr>
                <th>8</th>
                <td class="wall_color">&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td>&emsp;</td>
                <td class="wall_color">&emsp;</td>
                <td>&emsp;</td>
                <td class="walledia_color">&emsp;</td>
                <td>X</td>
            </tr>
        </table>
        <p>
            上面是列号的编号，左边是行号（用于二进制算术），然后变暗的单元格<span class="wall_color">&emsp;</span>表示墙壁。而且用十字架直接显示了玩家的位置（例如）在点1.0000008。这就是坐标的解读方式：
        </p>
        <ul>
            <li>整数部分 - 楼层数。</li>
            <li>
                小数部分的位数（零的数量） - 水平位置（列）。
            </li>
            <li>小数部分的数字 - 垂直位置（行）。</li>
        </ul>
        <p>
            考虑到这一点，迷宫的出口（预定义的） - 从点3.8向左。
        </p>
        <p>
            玩家有有限的资源：
        </p>
        <ul>
            <li>
                食物（原版为水，但由于存储在Re寄存器中，所以更方便称为食物）。每次移动都会消耗。
            </li>
            <li>
                炸药或手榴弹（为了记忆存储在Rd寄存器中，或在PMK表示法中<span class="code">&nbsp;Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>） - 用于炸毁墙壁（销毁它们）。
            </li>
            <li>
                简单的宝藏（类似地，存储在Rc中）。正是需要收集更多的这些。在这种修改版中，实际上至少可以收集十个（在一局游戏中）。
            </li>
        </ul>
        <p>
            可以通过寻找来补充资源（即可能没有）。因此，我们将它们称为宝藏。在这种情况下，第一层会有食物（+9，原版为+10），第二层会有炸药（+4），只有第三层有宝藏（+1）。特点 - 一旦找到，在所有楼层的相同单元格中就不再有宝藏。
        </p>
        <p>
            玩家的控制 - 指定移动命令，或寻找宝藏，或炸毁墙壁（最后一个无法通过的单元格）。每个命令都会消耗食物（炸毁墙壁，显然还要消耗炸药）。移动方向的代码由键盘上的数字相对于中心的位置确定：
            2,4,6,8,&plusmn;5 - 向下/向左/向右/向上以及上下楼层。
            炸毁墙壁用零表示（原版为数字<span class="but_f">F</span><span class="op_f">&pi;</span>，但通常在无法通过时显示0，所以直接使用它作为炸毁命令更方便）。
            寻找 - 数字10（原版为零，但1/0似乎暗示了找到/未找到）。
        </p>
        <p>
            如果移动成功，则在结束时显示玩家的新坐标（如上所述编码）。如果没有成功 - 零。
            迷宫的出口由数字11确定（原版为11路电车）。
        </p>
        <p>
            寻找宝藏时：如果未找到 - 零。
            如果找到，则显示资源的新数量，以及在Y寄存器中的宝藏类型字母和找到的位置，例如：
            <span class="code">&nbsp;E.00002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>。
            此时（如原版），可以与保护宝藏的强盗战斗（<span class="but">В&uarr;</span>）或跳过（<span class="but">0</span>），然后<span class="but_b">С/П</span>。
            如果战斗，那么考虑到找到的宝藏，该资源的总量可能会增加或减少。
        </<p>
        <p>
            成功炸毁墙壁 - 玩家的新位置，即炸毁意味着立即移动到新的单元格（原版需要单独移动）。如果失败 - 零。
        </p>
        <p>
            演示程序与原版已经提到的一些区别，但我们给出完整列表：
        </p>
        <ul>
            <li class="li_change">
                炸毁使用两个炸药（毕竟程序更复杂&#9786;）。
                实际上，改变了显示食物/炸药不足的方式，并使用这种“增加”来区分它们。
                因此，不是增加两个，而是增加四个，开始时也不是给两个，而是给四个。
            </li>
            <li class="li_change">
                缺乏炸药或食物时，分别显示-1或-2（食物或炸药）。
            </li>
            <li class="li_add">
                炸毁由数字零确定（而不是<big>&pi;</big>），并且玩家立即移动到新的单元格（否则为什么要炸毁？）。
            </li>
            <li class="li_add">
                寻找由数字10确定，而不是零。除了宝藏类型的字母外，还显示了宝藏在楼层上的位置（原版只有字母）。
            </li>
            <li class="li_add">
                墙壁被删除，而不是进行“异或”。尽管可以在代码中这样做（将<span class="but_k">К</span><span class="op_k">&or;</span>更改为<span class="but_k">К</span><span class="op_k">&oplus;</span>），但在我看来，放置新墙壁以阻碍通行是不明智的。
            </li>
            <li class="li_add">
                阻止从N.0000008意外“传送”到N.0000001（向右移动时的舍入特性）。原版中作者在几个地方放置了墙壁，以防止这种情况发生。
            </li>
            <li class="li_add">
                阻止炸毁“主要”墙壁。这些是迷宫边缘的墙壁（左边，右边，上面，下面，包括地下室和屋顶）。
            </li>
            <li class="li_add">
                不破坏返回堆栈。原版中，当出现ЕГГ0Г时，不执行<span class="but_b">В/О</span>命令，这会破坏返回堆栈。尽管这对程序本身的运行没有影响。
            </li>
            <li class="li_add">
                （除了宝藏）计数器的初始值由程序自动填充。不需要在游戏开始时输入。显然，“开始”也是以其他方式制作的。
            </li>
            <li class="li_add">
                <strong>最重要的是</strong> - PMK自己（！）生成迷宫和宝藏的位置（原版需要自己开发，编码并输入迷宫），并且在每场新游戏中，玩家的初始位置确保“不在墙壁上”。与原版相比，玩家没有迷宫和宝藏的计划。考虑到这一点，决定稍微增加初始食物量（从原来的30增加到36），因为计划是未知的，在探索过程中将多次遇到墙壁。此外，炸毁墙壁与移动到新地方合并。
            </li>
        </ul>
    </details>

<details id="div_demo_detail" open>
    <summary><h4>程序分析</h4></summary>
    我们将在最后提供完整的程序代码，而在叙述过程中，我们将介绍片段，研究技巧和使用未记录的PMK特性，如果没有这些特性，我们无法应对，考虑到所有的改进。首先是程序的总体算法。正如原版所说，这是展示PMK处理单个位（十六进制数）的能力的演示。楼层和宝藏的平面图由位掩码表示（一个数字就足够表示整个楼层），而玩家的位置实际上由一个位确定。正是这个位“移动”，通过叠加到位掩码上，确定是否可以通过。
    同样，掩码中的位在拾取宝藏时被删除（在拾取宝藏时）或在删除墙壁时被设置（在删除墙壁时）。
    程序的大部分代码是将玩家的移动转换为正确的位操作、检查边界、资源等。
    <p>
        寄存器的分配在很大程度上与原版相符。
    </p>
    <ul>
        <li>R0 - 宝藏平面图。</li>
        <li>R1...R3 - 1...3楼层的平面图。</li>
        <li>
            R4...R7 - 用于将移动转换为位操作的特殊数值常量：2；10；0.1；0.5（更确切地说，代替0.1的是另一个数字，但意义相同）。也就是说，取玩家位置的小数部分（楼层上的位置），并将其乘以指定的数值，就像向下（2）、向左（10）、向右（&#8530;）和向上（&frac12;）移动位一样。在原版中，这些都是通过编程计算的，但我更愿意将其放入内存寄存器中，以释放更多的命令空间。尽管这导致了内存寄存器的短缺。
        </li>
        <li>
            R8，R9 - 包含跳转地址和其他辅助常量，这些常量在游戏之间也不会改变。详细值将在叙述过程中介绍。
        </li>
        <li>
            Ra - 玩家当前位置的编码，如描述部分所示。
        </li>
        <li>
            Rb - 玩家未来的位置（他无法通过的位置）。同样，这个寄存器（只有一个！）被用作所有可能计算的工作寄存器，因此在“不移动”的时候，那里可能会有完全不同的值，但无论如何，爆炸都会控制这一点。
        </li>
        <li>
            Rc，Rd，Re，如上所述，用于存储资源（宝藏/炸药/食物）。
        </li>
    </ul>
    <p>
        那么，让我们从……开始。游戏是如何开始的（假设全局常量和程序本身已经输入）？是这样的：设置玩家在平面图上的初始位置，例如<span class="code">&nbsp;1.0000001&nbsp;&nbsp;&nbsp;</span>，然后<span class="but_b">БП</span>&ensp;
        <span class="but">48</span>&ensp;
        <span class="but_b">С/П</span>。
        现在就有一个片段：
    </p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td colspan=8></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">6</span></td>
				</tr>
				<tr>
					<th>&#8202;50&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
					<td colspan=7></td>
				</tr>
			</table>
<p>
    玩家的位置被记住在Rb中（就好像我们想去哪里一样）。我们取6个炸药作为初始数量，而不是4个，因为我们需要花费两个来移除玩家位置可能的墙壁 - 我们还不知道迷宫。36（6²） - 作为食物的初始数量。
    然后我们对R0寄存器进行巧妙的操作。由于间接寻址的特性，在第一次访问时零将变成-99999999，这对应于R3寄存器，然后是-99999998 - R2，依此类推，直到到达R0，在那里-99999996被新生成的正值覆盖！这就是我们在循环中跟踪的。
    循环返回到地址55，这个地址被记录在R8中（确切地说是-55，但这不影响寻址，为什么是负数我稍后会解释）。
    <span class="but_k">К</span><span class="op_k">&or;</span>操作数是通过<span class="but_k">К</span><span class="op_k">СЧ</span>函数<span class="but_f">F</span><span class="op_f">10ˣ</span>和<span class="but_f">F</span><span class="op_f">xʸ</span>获得的，这些函数将随机数的尾数数字“涂抹”到所有位上，使其更加随机。
    而且实验表明，对于第二个操作数来说，做<span class="but_f">F</span><span class="op_f">Вx</span>和<span class="but_f">F</span><span class="op_f">xʸ</span>比重复<span class="but_k">К</span><span class="op_k">СЧ</span>和<span class="but_f">F</span><span class="op_f">10ˣ</span>更有利（这样循环传感器就会被“打乱”）。
    喜欢迷宫复杂化（更多墙壁和更少宝藏）的人，可以将<span class="but_k">К</span><span class="op_k">&or;</span>替换为<span class="but_k">К</span><span class="op_k">&oplus;</span>。
</p>
<p>
    下一个片段，这又是开始……，但已经是程序形式了（我显示片段是为了以后更容易理解什么和怎样）：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">В/О</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan=8></td>
				</tr>
			</table>

<p>
    是的，就是这样一个小片段，所以显然需要解释。
</p>
<p>
    首先，我想指出，在R7中我们记录了0.5，这在间接寻址中给出了零地址（不改变R7），这意味着我们总是可以通过<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span>或其他类似的方式快速返回到开始。因此<span class="but_b">С/П</span>就位于最开始。
</p>
<p>
    但是，还有另一个问题。
    可以在没有<span class="but_b">В/О</span>的情况下将子程序放置在地址空间的末尾，因为由于地址空间的旁支，这个<span class="but_b">В/O</span>会“起作用”。更重要的是，尽管有四个逻辑子程序，程序实际上只包含这一个<span class="but_b">В/О</span>。
    两个子程序成功叠加在另一个的尾部，而最初的<span class="but_b">В/О</span>能够在两个不同的地址旁支中“起作用”。
</p>
<p>
    有时会利用返回方法的差异来区分情况。例如，在原版中，开始时有一个<span class="but_cx">Cx</span>，控制权在失败时返回到这里，或在成功时返回到+01。但我甚至设法节省了这个命令。稍后将解释如何做到这一点。
</p>
<p>
    在我们之前中断的初始化代码继续之前，我想介绍<strong>主要</strong>子程序，它进行位检查。
    首先给出形式化描述：输入时，X寄存器中期望有要检查的楼层平面图（位掩码）。Y寄存器中有玩家的位置（位）。执行后：Y的值将无条件写入Rb寄存器。如果位检查成功（匹配），则Y中的值也将进入Ra寄存器，Y中将保留小数部分（楼层上的位置），而值本身将已经在X中。
    如果位检查不成功，则将零返回到X和Y寄存器。
    让我们看看这是如何完成的。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">max</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
					<td colspan=2></td>
				</tr>
			</table>

<p>
    如果位乘法和将Y复制到Rb都很清楚，那么这里的<span class="but_k">К</span><span class="op_k">max</span>显然是“未记录的”。失败时，Y寄存器中的零将被“未记录地”复制为X中的“最大数”。也就是说，失败时将是零（这正是子程序所需要的）。
    如果位操作成功（有小数部分），那么什么也不会发生（即原始Y将保留在X中，而小数部分保留在Y中）。
    结果将被复制到Ra。
</p>
<p>
    实际上，这个子程序在其他情况下也很有用。如果（在输入时）X或Y寄存器中的一个数字由一个数字组成，那么这个程序将无条件地在输出时给出零。这个可能性也在程序中使用，因此我们也将其称为<strong>清除</strong>程序。
</p>
<p>
    但细心的读者会问，<span class="but_b">В/О</span>在哪里？
    它位于地址...零！
    这里使用了地址空间的旁支，但不是在105地址之后，而是在F9之后。是的，地址F9 = 47，这意味着如果子程序不是从地址41开始（好像），而是从相同的地址开始，但是作为F3，那么在地址F9（47）之后，控制将转移到00，即转到那个<span class="but_b">В/О</span>。
</p>
<p>
    现在可以透露，R9寄存器中的常数（用于调用此子程序）以F3结尾（也可以是ED）。更确切地说，在R9中存储的是<span class="code">&nbsp;4.&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</span>（或<span class="code">&nbsp;4.EГ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</span>，取决于谁更喜欢）。为什么首先是4，这样的顺序稍后将解释（尽管如果阅读了整个文档，那么已经提到了这一点）。最重要的是，这样的“附加物”不改变间接寻址。只需提及，在间接寻址“使用”后，R9中的值将变为非标准化的<span class="code">&nbsp;0.00004 3-03</span>，但会立即显示跳转地址。
</p>
<p>
    让我们继续初始化代码（迷宫的初始生成）。更确切地说，它已经结束，并平滑过渡到“炸毁”墙壁的子程序。这种“融合”的意义何在？首先，不需要任何<span class="but_b">БП</span>，其次，无论如何我们都需要确保在墙壁降落点没有墙壁，即好像将其移除（即使那里原本没有）。这就是为什么开始时多了两个炸药。那么：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td colspan=3></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td colspan=2></td>
				</tr>
			</table>

<p>
    这里似乎很明显，从炸药资源（Rd）中减去两个，检查是否剩下什么（不是负数），并将剩余部分保存回去。如果没有剩余炸药，则跳转到开始，带着这个"-2"，这在程序的意义上是需要的，用于信号没有炸药。而且，剩余部分的保存是在检查之后进行的，以免出现-2、-4、-6等。
    继续。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td colspan=8></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">4</span></td>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
					<td colspan=3></td>
				</tr>
			</table>
<p>
    提醒一下，要破解的墙壁的坐标位于Rb中。首先，我们检查这个值是否在R1...R3寄存器的范围内（即&lt;4），而且R0也会经过检查，但这没关系，原因如下。
    实际上，Rb中的数字小于1可能是一个数字（例如，想从第一层1.0002向下走，结果是0.0002），或者就是零（在尝试走出楼层边界时有这样的路径）。
    最重要的是，数字将是一个数字，即没有第二位数字，这意味着在这种情况下，楼层平面图将从R0的宝藏平面图中提取，因为通过Rb的间接寻址将等于零（是的，即使对于数字1.^-07，尾数的最后两位数字也将是零，这可以在间接寻址章节中查看）。然后<span class="but_k">К</span><span class="op_k">&or;</span>操作不会改变任何东西（第二个操作数没有数字），并将不变的值返回到R0。
    如果数字大于或等于4，我们将通过R9寄存器转到清除（清零）程序。考虑到程序其余部分的工作（这可以稍后估算），对于Rb >= 4，Rb中的数字要么是一个数字（破解左边的墙壁），清除程序将无条件工作，要么是“天花板”（Rb = 4.{&hellip;}）。但在R4中，我们也有一个一位数的常数，这意味着清除程序也会工作。
</p>
<p>
    对于R1...R3，这个操作将在楼层平面图中设置Rb中的位。
    在这种情况下，X中我们有楼层平面图，Y中我们要设置的破解点。在这种情况下，主程序将成功通过位检查（因为我们刚刚设置了这个位），并结束，将新位置写入Ra寄存器。也就是说，我们会立即移动到新位置。
</p>
<p>
    所以。初始化已完成。玩家在着陆点，那里没有墙壁。
    我们已经了解了来自R9寄存器的主要程序，它也是清除程序和破解墙壁的程序（从地址63开始），它仔细检查所有变体。现在我们可以回到停止点（初始<span class="but_b">С/П</span>）并开始最常见的（主要的）代码：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td colspan=2></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td colspan=2></td>
				</tr>
			</table>

<p>
    显然，食物的减少与炸药的减少类似，考虑到失败时会发放-1。请注意，如果我们排除我们的案例，即寄存器不够的情况，这里仍然可以节省一个命令。毕竟<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
    <span class="but_b">П&rarr;x</span><span class="but">R</span>是两个命令，而<span class="but">&lt;-&gt;</span>只有一个。
    但这当然是基于假设记住的值不会再需要。
    接下来。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td colspan=8></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">63</span></td>
					<td colspan=8></td>
				</tr>
			</table>

<p>
    这就是对破解墙壁命令的检查。"但是，请允许我问一下，为什么先做除法，然后再检查是否为零？"你会问。答案是我们没有足够的寄存器（顺便说一下，请注意，最后一次尝试移动的工作寄存器Rb还没有被使用，破解将基于它）。因此，我们记住用户的选择（更确切地说，已经是选择的一半&#9786;）在寄存器中……X2。是的，是的，回想一下，成功时条件检查会将X记住在X2中。接下来，让我们看看我们如何使用它：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td colspan=2></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">ВП</span></td>
					<td colspan=4></td>
				</tr>
			</table>

<p>
    啊哈，这里用户的选择已经转换为乘法系数的寄存器编号。为了澄清，我将提供一个表格，列出玩家可能的选择（已经排除了零），以及进入Rb寄存器的内容：
</p>

<table class="trcenter">
				<tr>
					<th>玩家移动</th><th>除以2之后</th><th>加3之后</th>
				</tr>
				<tr>
					<th>2</th><td>1</td><td>4</td>
				</tr>
				<tr>
					<th>4</th><td>2</td><td>5</td>
				</tr>
				<tr>
					<th>&plusmn;5</th><td>&plusmn;2.5</td><td>大于零的数值</td>
				</tr>
				<tr>
					<th>6</th><td>3</td><td>6</td>
				</tr>
				<tr>
					<th>8</th><td>4</td><td>7</td>
				</tr>
				<tr>
					<th>10</th><td>5</td><td>8</td>
				</tr>
			</table>

<p>
    ±5选项将不会使用Rb寄存器，我们稍后会看到。
</p>
<p>
    请注意，我们实际上不是与三相加，而是与数字<strong>π</strong>相加。为什么？因为命令<span class="but_f">F</span><span class="op_f">&pi;</span>不是X2影响的，而且在间接寻址中小数部分没有值（回想一下 - 这一切都在间接寻址章节中提到）。也就是说，对于我们来说，Rb中的数字是7还是7.1415926都无所谓，在<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>中它仍然会提取0.5（R7中的值）。
</p>
<p>
    最重要的是，这将是<span class="but">ВП</span>命令之后剩下的。
    让我们回想一下X2章节中的内容，这个命令与前面的保存到寄存器命令结合使用会“吃掉”X2中数字的第一位（还要注意，与<strong>π</strong>相加的结果在X中不是负数），并将其恢复到X中。那么我们在X2中有什么？这是上面表格中第二列的值。也就是说，它对于表中的所有选项都会留下零，只有±2.5会留下±0.5。
    看看一个未记录的命令能做多少事情！接下来处理向上/向下（±0.5）的选项：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td colspan=6></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">D4</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_b">БП</span></td>
					<td><span class="but">EA</span></td>
					<td colspan=8></td>
				</tr>
			</table>

<p>
    它做什么？它将楼层间的移动±0.5转换为±1（顺便说一下，这也是一个技巧，代替乘以2），然后跳转到某个地址EA。
    其他移动将从地址D4处理（如果有人不知道，在输入程序和输入这些地址时，不是按数字，而是按相应的字母按钮）。
    你会问，这是什么奇怪的地址？问题是，所有这些最终将在主程序中结束，该程序位于非标准地址，这意味着需要“包裹”当前执行分支。
    D4 - 就是地址22，也就是这段代码的结尾，而EA等于38。更准确地说，地址38对应于地址F0，但这样的不能输入，所以我们用类似物替换（技巧）。
    好吧，当我们到达那里时再处理这个地址，现在让我们继续在楼层上移动（或检查宝藏），但首先是神秘的提前跳过：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan=2></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
					<td colspan=7></td>
				</tr>
			</table>

<p>
    好了，是时候揭示R6寄存器中几乎为0.1的内容了。那里存储着数字D.^-02（<span class="code">&nbsp;Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>）。
    事实是，在乘法运算中，如果D在左边（在X中），那么它的行为就像10（谁忘了，回顾一下关于十六进制算术的章节），而对于-02的幂，结果是0.1（10 &times; 10⁻² = 10⁻¹）。而当它在右边（在Y中）时，那就更巧妙了。这种“巧妙”我们稍后会用到，所以现在先把数字压入栈中，以便它处于“右边”（我在脑海中将栈想象为X1&ndash;X&ndash;Y&ndash;Z&ndash;T，如果有人有不同的想法，请将“右边”替换为其他）。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan=3></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">77</span></td>
					<td></td>
				</tr>
			</table>

<p>
    好了，终于到了将Ra寄存器中的小数部分（楼层上的位置）乘以移动系数（别忘了我们在Rb中有的那个）。紧接着进行了寻找宝藏的选项剪切。事实是，在R8中（选项10 / 2 + 3）
    数字是负数（-55，如果有人忘了，这就解释了为什么是负数），这意味着搜索将转移到地址77。但这还不是全部。
    这里我们再次使用X2寄存器（通过影响X2的操作比较）。
    我们将玩家在楼层上的新位置保存在X2中，不是因为没有寄存器，而是为了节省命令：
    <span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
    <span class="but_b">П&rarr;x</span><span class="reg">b</span>是两个命令，而<span class="but">.</span>只有一个，但比较仍然需要做。这就是为什么比较不是在<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>之后立即进行，而是在乘法之后进行，以便在X2中记住结果。
</p>
<p>
    好了，现在，在得到楼层上的新值之后，我们需要检查我们是否没有走出楼层的边界。让我们更详细地研究这样的检查。
</p>
<p>
    首先考虑左边界。我们怎么能越过它呢？只有在我们之前有数字M.N（M=1,2,3; N=1,2,4,8），然后我们用N乘以10。显然，然后我们会在楼层M上加上“小数”部分。在这种情况下，它甚至不是很小的，但最终结果的选择并不多，最重要的是，它们将在2...11的范围内，并且只由一个数字组成（除了11）。而一个数字的二进制与运算（<span class="but_k">К</span><span class="op_k">&and;</span>）
    在清除过程中“不会存活”。11的选项（从3.8向左）是例外，因此它被选为迷宫的出口。
    并且将执行操作
    <span class="but">1</span>
    <span class="but">1</span>
    <span class="op_k">&and;</span>
    <span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>。
    也就是说，即使是Rb寄存器（b = 11，谁忘了）也不是偶然选择的（寄存器操纵的技巧！）。
    总之，左边界“自动保护”了。
</p>
<p>
    右边界。那里小数部分的值变成1.^-08的顺序，在与楼层号码相加时简单丢失（精度不足以达到9位数字），再次只留下一整个部分，它将是1...3，并且与运算不会存活。
    例外是8.^-08（四舍五入到1.^-07），但我们稍后会战胜它。
</p>
<p>
    上和下。在越过上边界（1 &times; 0.5）时，得到的数字以5结尾，而在越过下边界（8 &times; 2）时，数字由两个数字组成。这时我们就需要R6中神秘的D.^-02了。使用十六进制算术的知识可以知道，当乘以1、2、4或8时（D.^-02恰好在右边），结果将只包含一个数字，而对于5和尤其是16则更多。
    这解释了后面的代码：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan=9></td>
					<td><span class="but">&times;</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
					<td colspan=7></td>
				</tr>
			</table>

<p>
    除了上述内容外，这里还应用了另一个技巧。乘法之后将得到一个或多个数字的数字。
    那么如何计算一个或多个呢？在这里，<span class="but_k">К</span><span class="op_k">&or;</span>操作派上了用场，因为在地址15处的<span class="but">ВП</span>命令之后，Y寄存器中仍然保留了一个零（多么周到的作者啊，连很久以前的零都在使用&#9786;）。
    结果将是8. - 一切都好，或者是8.{带点什么} - 不好，然后在<span class="but_k">К</span><span class="op_k">{x}</span>之后要么是零，要么是0.{一些东西}。这个不好的“一些东西”将被最后一个命令发送到清除程序。对于清除来说，重要的是X或Y寄存器中有一个数字的数字 - Y中的零完全可以（是的，在逻辑二进制运算中，第二个操作数不会消失，但这是有文档记录的）。
    我们继续。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td colspan=3></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">-</span></td>
					<td colspan=4></td>
				</tr>
			</table>

<p>
    我们首先做的是从地址17的比较命令中恢复X2（楼层上的新位置），因为在此期间的所有命令都不是影响X2的。然后我们校正该值，增加一个大约为4^.-08的小量。这对任何人来说都不会改变结果，除了8.^-08。在这种情况下，它也会变得非常小。这就是“传送”被阻止的地方，也是为什么在R9的跳转地址前添加了四和-08顺序的原因。
    接下来更简单：
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td colspan=6></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td colspan=9></td>
				</tr>
			</table>
<p>
    我们将楼层号码（Ra的整数部分）加到我们在楼层上的新值上，将新的坐标推入Y，而在X中保留楼层平面图。实际上，Rb可能得到的不仅仅是1...3，而是其他数字，因此转到主程序（它紧随地址41 = F3之后，我们已经看过了），它将丢弃所有非标准楼层（数字中的一个数字），以及当楼层位图简单地与玩家位置不符的情况。请注意，主程序将在Rb中记住新位置的完整值，即即使无法通过楼层，我们也会记住想要到达的点。在成功的情况下，该程序将自动更新Ra的内容。
</p>
<p>
    让我们回想一下跳转地址38 = EA，我们在楼层间移动时会到达那里。结果是 - 一个平凡的加号，但考虑到早期的±1和提取的Ra，这是“医生开的药”（向上/向下）。这样，向上/向下移动的选项平滑地融入了当前代码片段（又一个技巧）。
</p>
<p>
    好了，主要代码部分已经考虑过了，剩下的是寻找宝藏（和强盗！）。那里的事情也不简单。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td colspan=7></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td colspan=6></td>
				</tr>
			</table>

<p>
    在这里，我们使用主程序来检查位（获取宝藏的可能性）。同时，我们将Ra的内容放入Y寄存器，以便在成功时，它也会保存在Ra中（这是主程序操作的事实）。显然，如果没有更多的宝藏（在正确的位置移除了位），那么我们就返回到开始。接下来，我们从R0寄存器中的掩码中移除宝藏的位。
</p>
<p>
    现在，我们将提供一段代码，它将根据楼层号码获得十六进制数字，对应关系为1 = E，2 = D，3 = C。
    在原版中，作者使用了预先保存的常量“E”和通过R0寄存器递减它的循环来实现这一点。我们将做同样的事情，但不使用额外的寄存器并且更短，利用未记录的功能。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td colspan=4></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td colspan=9></td>
				</tr>
			</table>

<p>
    这里我们又需要回顾一下关于X2寄存器和<span class="but">ВП</span>命令的部分，该命令用于恢复它。首先，我们通过加上10（来自R5的常量）将楼层号码推入第二位。
    这里操作数的顺序很重要，因为最后一个<span class="but_b">П&rarr;x</span>将包含在X2中。
    然后，通过反转和截断整数部分（第一个数字），我们得到所需的字母位于第一位。但是在X中似乎还有其他东西？那么，通过<span class="but">ВП</span>恢复X2，将确保在恢复X2时，只有X中的第一个数字会保留，即2.00004将恢复为D.00004。这正是我们需要的。还需要记住，在<span class="but">ВП</span>之前必须是任何不影响X2的命令，该命令将被执行，但结果被忽略。通常为此目的使用<span class="but_k">К</span><span class="op_k">НОП</span>，但我们使用<span class="but_k">К</span><span class="op_k">СЧ</span>。原因是主程序可能会使用<span class="but_k">К</span><span class="op_k">max</span>与Y中的零，这会“重置”随机数生成器。对于后续游戏（万一想走另一个迷宫），最好“激活”随机数生成器（“从坏羊身上拔毛也行” - 即使是忽略的命令，我们也试图获得效果）。我们继续。
</p>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">С/П</span></td>
					<td></td>
				</tr>
			</table>
<p>
    我们将获得的带有小数部分的字母保存在Rb中，并将其留在堆栈中以供玩家信息。然后我们不仅提取旧的资源值，而且同时从字母中截断小数部分（通过间接寻址），以便稍后将其转换为所需的加数。
    这里需要解释一下，根据X寄存器的值（C、D或E），到底发生了什么来计算“加数”。
    在减法中应用十六进制算术规则。
</p>

<table class="trcenter">
				<tr>
					<th>X</th>
					<th>在 "&minus; 1" 之后</th>
					<th>在 x&sup2; 之后</th>
				</tr>
				<tr>
					<th>C</th>
					<td>1</td><td>1 (сокровище-宝藏)</td>
				</tr>
				<tr>
					<th>D</th>
					<td>2</td><td>4 (динамит-炸药)</td>
				</tr>
				<tr>
					<th>E</th>
					<td>3</td><td>9 (еды-食物)</td>
				</tr>
			</table>

<p>
    与强盗搏斗的代码完全取自原版。最重要的是，R-GRD-G开关必须处于R位置。最终资源值被保存。
</p>
<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td colspan=9></td>
					<td><span class="but_f">F</span><span class="op_f">sin</span></td>
				</tr>
				<tr>
					<th>&#8202;A0&#8202;|&#8202;</th>
					<td><span class="but">1</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td colspan=5></td>
				</tr>
			</table>
<p>
    这就是全部，最终的<span class="but_b">В/О</span>在地址A5（或00）"触发"，以"摆脱"小程序的小分支并返回正常流程。
</p>
</details>

<details id="div_demo_full" open>
    <summary><h4>程序完整文本</h4></summary>

<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">В/О</span></td>
					<td><span class="but_b">С/П</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">63</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">D4</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_b">БП</span></td>
					<td><span class="but">EA</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">77</span></td>
					<td><span class="but">&times;</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">max</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">6</span></td>
				</tr>
				<tr>
					<th>&#8202;50&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">4</span></td>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">С/П</span></td>
					<td><span class="but_f">F</span><span class="op_f">sin</span></td>
				</tr>
				<tr>
					<th>&#8202;A0&#8202;|&#8202;</th>
					<td><span class="but">1</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td colspan=5></td>
				</tr>
			</table>

<p>
    初始常数值（在游戏之间不变）：
</p>
<ul>
    <li>R4 = 2</li>
    <li>R5 = 10</li>
    <li>R6 = D.^-02
        (<span class="code">&nbsp;Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>
    </li>
    <li>R7 = 0.5</li>
    <li>R8 = -55（带负号）</li>
    <li>
        R9 = 4.F3^-08
        (<span class="code">&nbsp;4. 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</span>
    </li>
</ul>
<p>
    这是输入常数的顺序：
    <br>
<span class="but">5</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">8</span>
				<br>
				<span class="but">4</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">В&uarr;</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_k">К</span><span class="op_k">&or;</span>&ensp;
				<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">9</span>
				<br>
				<span class="but">1</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">5</span>
				<br>
				<span class="but">2</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">4</span>
				<br>
				<span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">7</span>
				<br>
				<span class="but">2</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
				<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="op_k">[x]</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">6</span>
			</p>
<p>
    R-GRD-G开关的位置必须在R。
    在第一场游戏之前（或者如果你不想积累宝藏，每场游戏之前），需要将Rc寄存器清零。
</p>
<p>
    我提醒一下开始游戏的顺序：设定玩家在平面图上的初始位置，例如1.0000001 - 可以快速获得，如
    <span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
    <span class="but_f">F</span><span class="op_f">10ˣ</span>
    （有人可能会认为作者甚至预见了这一点，但不是，这只是偶然巧合）。
    然后<span class="but_b">БП</span>&ensp;
    <span class="but">48</span>&ensp;
    <span class="but_b">С/П</span>
</p>
</details>

<details id="div_demo_tricks" open>
    <summary>
        <h4>程序中使用的技巧和未记录的特性列表</h4>
    </summary>
    我们在程序中使用它们以缩短其长度（以便一切都能容纳）。
    <ul>
        <li>
            跳转地址存储在寄存器中，以减少间接寻址时命令的长度。对于R7，这是地址05、46、66和80的命令。对于R8 - 地址62的命令。对于R9 - 地址32、71、76、79的命令。
        </li>
        <li>
            常数的两种意义。R5 - 作为地址26处的乘法系数，也用于地址86处的“移位”到第二位。R7 - 也作为乘法系数，但也作为跳转地址。R8 - 除了间接寻址外，还用于地址27处检查寻宝移动的负数。R9 - 除了间接寻址外，还用于地址34处的舍入校正。
        </li>
        <li>
            地址空间的循环性。在地址47处的命令之后的程序中没有<span class="but_b">В/О</span>命令，程序中的最后一个命令也不是<span class="but_b">В/О</span>，它“恰好”位于零地址，适用于这些情况。
        </li>
        <li>
            一个程序的尾部用于另一个程序：“主要子程序”从多个地方调用，紧随计算新位置（地址41）之后。
        </li>
        <li>
            将一个程序的结束与另一个程序的开始“合并”以排除跳转命令。在这种情况下，初始化的结束和炸墙的开始位于地址63。以及两个计算分支（楼层间和楼层内）在地址38的合并。
        </li>
        <li>
            寄存器X2。几次。在地址10处保存，以便在地址15处提取，此时值已经参与了加法操作（节省寄存器），并且使用了不影响X2的<strong>&pi;</strong>代替三。在地址27处保存并在地址33处恢复（节省一个命令）。在地址85处保存并在地址90处非标准恢复（节省几个命令）。
        </li>
        <li>
            使用ВП。将X2的恢复与地址15处的隐式取小数部分操作结合。在地址90处结合X2和十六进制数字。
        </li>
        <li>
            使用间接寻址知识。除了R7...R9寄存器中的值外，这是在地址13或38处加法后“忽略”小数部分，并在地址92处故意“切断”它。以及在地址62处的循环中使用R0寄存器和负计数器的不寻常用法。
        </li>
        <li>
            <span class="but_k">К</span><span class="op_k">ЗН</span>作为地址19处的乘以2命令。
        </li>
        <li>
            <span class="but_k">К</span><span class="op_k">&or;</span>用于在地址30处检查数字是否包含多于一个数字。这里应该与原文进行比较，原文中作者使用新位置的平方和数字<strong>&pi;</strong>的结合来检查上下边界是否越界，检查第二位中的零位（and 1）（在平方之后5**2 = 25和16**2 = 256包含它们，而1**2 = 1, 2**2 = 4, 4**2 = 16, 8**2 = 64 - 不包含）。看来，这看起来像是替代方案，而不是使用命令<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
            <span class="but">&times;</span>&ensp;
            <span class="but_k">К</span><span class="op_k">&or;</span>使用
            <span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
            <span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
            <span class="but_k">К</span><span class<pot>
    <h4>程序中使用的技巧和未记录的特性列表</h4>
    我们在程序中使用它们以缩短其长度（以便一切都能容纳）。
    <ul>
        <li>
            跳转地址存储在寄存器中，以减少间接寻址时命令的长度。对于R7，这是地址05、46、66和80的命令。对于R8 - 地址62的命令。对于R9 - 地址32、71、76、79的命令。
        </li>
        <li>
            常数的两种意义。R5 - 作为地址26处的乘法系数，也用于地址86处的“移位”到第二位。R7 - 也作为乘法系数，但也作为跳转地址。R8 - 除了间接寻址外，还用于地址27处检查寻宝移动的负数。R9 - 除了间接寻址外，还用于地址34处的舍入校正。
        </li>
        <li>
            地址空间的循环性。在地址47处的命令之后的程序中没有<span class="but_b">В/О</span>命令，程序中的最后一个命令也不是<span class="but_b">В/О</span>，它“恰好”位于零地址，适用于这些情况。
        </li>
        <li>
            一个程序的尾部用于另一个程序：“主要子程序”从多个地方调用，紧随计算新位置（地址41）之后。
        </li>
        <li>
            将一个程序的结束与另一个程序的开始“合并”以排除跳转命令。在这种情况下，初始化的结束和炸墙的开始位于地址63。以及两个计算分支（楼层间和楼层内）在地址38的合并。
        </li>
        <li>
            寄存器X2。几次。在地址10处保存，以便在地址15处提取，此时值已经参与了加法操作（节省寄存器），并且使用了不影响X2的<strong>&pi;</strong>代替三。在地址27处保存并在地址33处恢复（节省一个命令）。在地址85处保存并在地址90处非标准恢复（节省几个命令）。
        </li>
        <li>
            使用ВП。将X2的恢复与地址15处的隐式取小数部分操作结合。在地址90处结合X2和十六进制数字。
        </li>
        <li>
            使用间接寻址知识。除了R7...R9寄存器中的值外，这是在地址13或38处加法后“忽略”小数部分，并在地址92处故意“切断”它。以及在地址62处的循环中使用R0寄存器和负计数器的不寻常用法。
        </li>
        <li>
            <span class="but_k">К</span><span class="op_k">ЗН</span>作为地址19处的乘以2命令。
        </li>
        <li>
            <span class="but_k">К</span><span class="op_k">&or;</span>用于在地址30处检查数字是否包含多于一个数字。这里应该与原文进行比较，原文中作者使用新位置的平方和数字<strong>&pi;</strong>的结合来检查上下边界是否越界，检查第二位中的零位（and 1）（在平方之后5**2 = 25和16**2 = 256包含它们，而1**2 = 1, 2**2 = 4, 4**2 = 16, 8**2 = 64 - 不包含）。看来，这看起来像是替代方案，而不是使用命令<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
            <span class="but">&times;</span>&ensp;
            <span class="but_k">К</span><span class="op_k">&or;</span>使用
            <span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
            <span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
            <span class="but_k">К</span><span class="op_k">&and;</span>，在假设<strong>&pi;</strong>位于“右侧”（以便正确执行清除程序，这得益于切除第一位数字，以及<strong>&pi;</strong>的2和3位不相交：对于3.14...这是1和4）的情况下。这甚至可以做到，程序的长度不会改变，甚至R6也可以做成普通的0.1。
            但这里有一个隐患：
            清除程序也会在Rb中记住“右侧”的数字，而对于炸墙和检查边界程序，数字中的位数是不允许的（清除程序不会清除，而是在Ra中带来一些随机的东西）。这就是为什么有时不得不使用未记录的功能来实现算法的正确行为（不增加程序的长度）。
        </li>
        <li>
            使用十六进制算术。R6寄存器的内容在地址26处用作0.1，在地址29处用作增加有效数字的数量。地址95处的减法操作将C、D、E数字转换为更方便的1、2、3。
        </li>
        <li>
            在非标准情况下使用<span class="but_k">К</span><span class="op_k">max</span>来“照亮”Y中的零，地址为45。这里需要注意的是，地址41处的程序可以用不同的方式实现。例如这样：
            <span class="but">&lt;-&gt;</span>&ensp;
            <span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
            <span class="but_k">К</span><span class="op_k">&and;</span>&ensp;
            <span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
            <span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span>&ensp;
            <span class="but_b">П&rarr;x</span><span class="reg">b</span>&ensp;
            <span class="but_b">x&rarr;П</span><span class="reg">a</span>。
            但此时，栈中会保留失败时的楼层/宝藏平面图。而我们希望避免这个提示，因为许多游戏命令都假设在停止后Y寄存器中有额外的信息。
            根据我们的顺序，楼层/宝藏平面图无论如何都会从栈中永久丢失（无论成功与否）。
        </li>
    </ul>
    <p>
        奇怪的是，即使是这样“紧凑”的程序也可以进一步改进。
        例如，如果要求在每场游戏开始时，在输入初始位置后按<span class="but">В&uarr;</span>再按<span class="but_b">C/П</span>。然后可以将开始移到地址44，在那里已经有一个命令<span class="but_b">x&rarr;П</span><span class="reg">b</span>，并从地址48中删除它。顺便说一句，这将实现一个罕见的技巧，与在不同地址分支中执行相同的命令有关（并且有不同的目标和结果）。
        然后，例如，使用节省的命令来初始化宝藏数量，例如在地址54处使用<span class="but_b">x&rarr;П</span><span class="reg">с</span>。
    </p>
</details>

<hr>

<details id="div_command" open>
    <summary><h3>附录。所有命令</h3></summary>
    包含256个PMK命令的列表，以及对未记录功能的额外注释（如果有的话）。
    <p></p>
    <table>
        <tr><th>代码</th><th>类型</th><th>名称</th><th>注释</th></tr>
        <tr>
            <th>00&hellip;09</th>
            <td class="tdcenter">
                <span class="but">0</span>&hellip;<span class="but">9</span>
            </td>
            <td>输入数字</td>
            <td>
                即使通过<span class="but_b">C/П</span>边界，数字的输入也会继续。也就是说，如果在程序开始时有一个或多个数字，并且在启动它之前还有输入，那么输入将继续。
                这也适用于分隔符<span class="but">.</span>，它可以作为计算模式下的输入结束，也可以作为程序中的开始 - 将被视为整数和小数部分的分隔符。
                <br>
                第二次按下<span class="but">.</span>以分隔位数将被忽略。
                <br>
                如果前一个命令不是输入数字或分隔符，也不是命令<span class="but">В&uarr;</span>，则会先将堆栈为新数字移位。
            </td>
        </tr>
        <tr>
            <th>0A</th>
            <td class="tdcenter"><span class="but">.</span></td>
            <td>整数和小数部分的分隔符</td>
            <td>
                除了上述内容外，还有X2&rarr;X的恢复。参见<a href="#div_x2_point">神秘的寄存器X2</a>。
            </td>
        </tr>
        <tr>
            <th>0B</th>
            <td class="tdcenter"><span class="but">/-/</span></td>
            <td>改变符号</td>
            <td>
                先前的值不会复制到X1。
                另见<a href="#div_x2_sum">神秘的寄存器X2</a>。
            </td>
        </eln>
        <tr>
            <th>0C</th>
            <td class="tdcenter"><span class="but">ВП</span></td>
            <td>输入阶数</td>
            <td>
                如果X = 0，则将其替换为1。对于许多数字，输入阶数意味着乘以相应的10的幂。
                <br>
                输入阶数后，可以再次按下<span class="but">ВП</span>并输入数字 - 在这种情况下，阶数相加。
                <br>
                阶数的符号可以立即在<span class="but">ВП</span>之后输入，也可以在输入数字后输入。
                <br>
                另见<a href="#div_x2_exp">神秘的寄存器X2</a>。
            </td>
        </tr>
<tr>
    <th>0D</th>
    <td class="tdcenter"><span class="but_cx">Сx</span></td>
    <td>将X重置为零</td>
    <td>重要属性 - 栈不会移动。</td>
</tr>
<tr>
    <th>0E</th>
    <td class="tdcenter"><span class="but">В&uarr;</span></td>
    <td>栈移位</td>
    <td>
        如果后续命令是输入数字，则输入到X中，如果是从内存中提取或F<big>&pi;</big> - 则栈将再次移动。
    </td>
</tr>
<tr>
    <th>0F</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">Вx</span></td>
    <td>包括X1在内的完整移位</td>
    <td>
        唯一一个有文档记录且带有数字F的输入命令。
    </td>
</tr>
<tr>
    <th>10</th>
    <td class="tdcenter"><span class="but">+</span></td>
    <td>加法</td>
    <td>
        结果仅在X&rarr;X2时检查，即可以用于获得超大数。
    </td>
</tr>
<tr>
    <th>11</th>
    <td class="tdcenter"><span class="but">-</span></td>
    <td>减法</td>
    <td>
        结果仅在X&rarr;X2时检查，即可以用于获得超大数。
    </td>
</tr>
<tr>
    <th>12</th>
    <td class="tdcenter"><span class="but">&times;</span></td>
    <td>乘法</td>
    <td>
        结果在X&rarr;X2时检查，即可以用于获得超大数。
    </td>
</tr>
<tr>
    <th>13</th>
    <td class="tdcenter"><span class="but">&divide;</span></td>
    <td>除法</td>
    <td>
        除以零的错误不可避免，其他情况在X&rarr;X2时。
    </td>
</tr>
<tr>
    <th>14</th>
    <td class="tdcenter"><span class="but">&lt;-&gt;</span></td>
    <td>交换X和Y</td>
    <td></td>
</tr>
<tr>
    <th>15</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">10ˣ</span>
    </td>
    <td>数的10次幂</td>
    <td>
        论证溢出阶数（超大数）是无条件检查的，而不是在X&rarr;X2时。
    </td>
</tr>
<tr>
    <th>16</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">eˣ</span>
    </td>
    <td>数的e次幂（指数）</td>
    <td>
        论证溢出阶数（超大数）是无条件检查的，而不是在X&rarr;X2时。
    </td>
</tr>
<tr>
    <th>17</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">lg</span></td>
    <td>十进制对数</td>
    <td>
        论证（必须大于零）是无条件检查的，而不是在X&rarr;X2时。
    </td>
</tr>
<tr>
    <th>18</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">ln</span></td>
    <td>自然（指数）对数</td>
    <td>
        论证（必须大于零）是无条件检查的，而不是在X&rarr;X2时。
    </td>
</tr>
<tr>
    <th>19</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">sin⁻¹</span>
    </td>
    <td>反正弦</td>
    <td>
        参数（必须|X|&les;1）是无条件检查的，而不是在X&rarr;X2时。对于GRD/G和X = 0，输出X = 00。
    </td>
</tr>
<tr>
    <th>1A</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">cos⁻¹</span>
    </td>
    <td>反余弦</td>
    <td>
        参数（必须|X|&les;1）是无条件检查的，而不是在X&rarr;X2时。对于GRD/G，arccos(1)不会给出标准化的00。
    </td>
</tr>
<tr>
    <th>1B</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">tg⁻¹</span>
    </td>
    <td>反正切</td>
    <td></td>
</tr>
<tr>
    <th>1C</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">sin</span></td>
    <td>正弦</td>
    <td></td>
</tr>
<tr>
    <th>1D</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">cos</span></td>
    <td>余弦</td>
    <td></td>
</tr>
<tr>
    <th>1E</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">tg</span></td>
    <td>正切</td>
    <td>
        参数是无条件检查的，而不是在X&rarr;X2时。
        当X = <big>&pi;</big>/2 + n &times; <big>&pi;</big>时，将出现错误。
    </td>
</tr>
<tr>
    <th>1F</th>
    <td></td>
    <td>空操作符</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>20</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">&pi;</span></td>
    <td>数字<big>&pi;</big>（π）</td>
    <td>
        除了移动栈（这是有文档记录的），它还将之前的X复制到X1，就像算术操作一样（但这不是）。
    </td>
</tr>
<tr>
    <th>21</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">&radic;</span>
    </td>
    <td>平方根</td>
    <td>参数是无条件检查的（X&ges;0），而不是在X&rarr;X2时。</td>
</tr>
<tr>
    <th>21</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">x&sup2;</span>
    </td>
    <td>平方</td>
    <td>
        结果在X&rarr;X2时检查，即可以用于获得超大数。
    </td>
</tr>
<tr>
    <th>23</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">1/x</span></td>
    <td>倒数</td>
    <td>
        除以零的错误不可避免，其他情况在X&rarr;X2时。
    </td>
</tr>
<tr>
    <th>24</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">xʸ</span>
    </td>
    <td>幂运算</td>
    <td>
        如果X = 0，则会出现错误。即使数学上允许，也不接受负X。
        <br>
        溢出错误是无条件发生的，而不是在X&rarr;X2时。
        <br>
        与常规算术运算不同，栈不会缩减。也就是说，Y中的数字保持在原位（允许再次将其提升到相同的幂）。
    </td>
</tr>


<tr>
    <th>25</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">&orarr;</span>
    </td>
    <td>栈上提</td>
    <td></td>
</tr>
<tr>
    <th>26</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>
    </td>
    <td>
        将角度或时间量从普通形式转换为整数部分
    </td>
    <td>
        如果小数值&gt;=0.6，则会出现错误。
        整数部分不会改变，即使是十六进制数。
    </td>
</tr>
<tr>
    <th>27</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="but">&minus;</span>
    </td>
    <td>错误</td>
    <td>ЕГГ0Г。</td>
</tr>
<tr>
    <th>28</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="but">&times;</span>
    </td>
    <td>错误</td>
    <td>ЕГГ0Г。</td>
</tr>
<tr>
    <th>29</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="but">&divide;</span></td>
    <td>错误</td>
    <td>ЕГГ0Г。</td>
</tr>
<tr>
    <th>2A</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
    </td>
    <td>
        将角度或时间量从普通形式转换为整数部分，包括秒
    </td>
    <td>
        如果小数值&gt;=0.6，则会出现错误。
        整数部分不会改变，即使是十六进制数。
    </td>
</tr>
<tr>
    <th>2B&hellip;2E</th>
    <td></td>
    <td>错误</td>
    <td>ЕГГ0Г。</td>
</tr>
<tr>
    <th>2F</th>
    <td></td>
    <td>空操作符</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>30</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
    </td>
    <td>
        将角度或时间量从整数部分转换为普通形式，包括秒
    </td>
    <td>
        如果小数部分&lt; 2^.-07，则反向转换不再有效。如果= 1^.-07，则直接转换也不会改变值。如果整数部分是十六进制数且没有小数部分或其= 1^.-07 - 它将<a href="#div_glos_normalization">标准化</a>，如同在十六进制数字操作中。否则保持不变。
    </td>
</tr>
<tr>
    <th>31</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&mid;x&mid;</span>
    </td>
    <td>模</td>
    <td></td>
</tr>
<tr>
    <th>32</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">ЗН</span></td>
    <td>数字的符号</td>
    <td>负零转换为零。</td>
</tr>
<tr>
    <th>33</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>
    </td>
    <td>
        将角度或时间量从整数部分转换为普通形式
    </td>
    <td>
        如果小数部分&lt; 2^.-07，则反向转换不再有效。如果= 1^.-07，则直接转换也不会改变值。如果整数部分是十六进制数且没有小数部分或其= 1^.-07 - 它将<a href="#div_glos_normalization">标准化</a>，如同在十六进制数字操作中。否则保持不变。
    </td>
</tr>
<tr>
    <th>34</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">[x]</span></td>
    <td>整数部分</td>
    <td>
        简单地丢弃小数部分，而不是数学上找到整数部分，即[-1.2] = -1，而不是-2。
        <br>
        如果数字是整数且为十六进制 - 它会像在十六进制数字操作中那样转换。如果有小数部分，则十六进制的整数部分保持不变。
    </td>
</tr>
<tr>
    <th>35</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">{x}</span></td>
    <td>小数部分</td>
    <td>
        简单地丢弃整数部分，而不是数学上找到整数部分，即{-1.2} = -0.2，而不是0.8。
        <br>
        对于模&lt; 10<sup>7</sup>（更确切地说是需要少于八个有效数字的数字）的整数，得到负零（在比较中作为负数和零）。即{-1234567} = -0，但{-12345678} = 0。
        <br>
        十六进制数字（在小数部分）被保留。
    </td>
</tr>
<tr>
    <th>36</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">max</span></td>
    <td>最大值</td>
    <td>
        零除外 - 最大的数字。
        <br>
        不交换X和Y，即操作后X和Y要么相同（如果Y中是最大值），要么保持不变（除了复制X到X1）。
    </td>
</tr>
<tr>
    <th>37</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&and;</span>
    </td>
    <td>逻辑乘（AND）</td>
    <td rowspan="4">
        在逻辑运算中，第一个数字被替换为8，而其他数字上的操作数进行按位操作，就像处理十六进制数字一样。原始数字的顺序和符号无关紧要，它们甚至可以是空值。
        结果始终以8.HHHHHHH的形式出现
        <br>
        两个操作数的栈不会缩减，这允许再次执行操作。
    </td>
</tr>
<tr>
    <th>38</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">&or;</span></td>
    <td>逻辑加（OR）</td>
</tr>
<tr>
    <th>39</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_k">&oplus;</span>
    </td>
    <td>逻辑异或（XOR）</td>
</tr>
<tr>
    <th>3A</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
    <td>逻辑非（NOT）</td>
</tr>
<tr>
    <th>3B</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">СЧ</span></td>
    <td>随机数</td>
    <td>
        不会出现单位。零在罕见的情况下出现（当Y中是十六进制数时，序列可能会产生零）。
        传感器不是很好，经常循环（由于使用К命令）。
        <br>
        可以通过在Y为零时使用操作<span class="but_k">К</span><span class="op_k">max</span>来重置为开始（如同开机时）。
    </td>
</tr>
<tr>
    <th>3C</th>
    <td></td>
    <td>错误</td>
    <td>ЕГГ0Г。</td>
</tr>
<tr>
    <th>3D</th>
    <td></td>
    <td>
        与命令<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>（代码2A）相同
    </td>
    <td></td>
</tr>
<tr>
    <th>3E</th>
    <td></td>
    <td>将Y复制到X（并且X&rarr;X1）</td>
    <td>
        与命令对<span class="but_f">F</span><span class="op_f">&orarr;</span>&ensp;
        <span class="but">В&uarr;</span>相同，只是不影响X2。
    </td>
</tr>
<tr>
    <th>3F</th>
    <td></td>
    <td>空操作符</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>40&hellip;4E</th>
    <td class="tdcenter">
        <span class="but_b">x&rarr;П</span><span class="but">R</span>
    </td>
    <td>将X保存到寄存器R0&hellip;Re</td>
    <td></td>
</tr>
<tr>
    <th>4F</th>
    <td class="tdcenter"></td>
    <td>将X保存到寄置R0</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>50</th>
    <td class="tdcenter"><span class="but_b">С/П</span></td>
    <td>停止/启动</td>
    <td></td>
</tr>
<tr>
    <th>51</th>
    <td class="tdcenter"><span class="but_b">БП</span></td>
    <td>无条件跳转</td>
    <td></td>
</tr>
<tr>
    <th>52</th>
    <td class="tdcenter"><span class="but_b">В/О</span></td>
    <td>返回</td>
    <td>
        子程序的反向地址栈有5个单元，最初为零。
        从子程序返回时，取栈顶单元的值+1（用于确定返回点），然后栈移动，
        因此在打开PMK后立即执行命令<span class="but_b">В/О</span>等同于
        <span class="but_b">БП</span><span class="but">01</span>。
        但如果返回地址栈已满，则栈的最后一个地址开始复制，<span class="but_b">В/О</span>
        将在此地址+1。在这种情况下，要清空栈，可以利用Eggo学知识并调用零3Г0ГГ：
        <p>
            <span class="but_cx">Cx</span>&ensp;
            <span class="but">В&uarr;</span>&ensp;
            <span class="but">&divide;</span>&ensp;
            <span class="but">ВП</span>&ensp;
            <span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
            <span class="but_cx">Cx</span>&ensp;
            <span class="but">&lt;-&gt;</span>&ensp;
            <span class="but_cyl">Cx</span>
        </p>
        或者短暂启动一个无限程序，例如
        <span class="code_num">00.</span><span class="but_k">K</span><span class="but_b">ПП</span><span class="but">9</span>，
        前提是R9 = 0。
    </td>
</tr>
<tr>
    <th>53</th>
    <td class="tdcenter"><span class="but_b">ПП</span></td>
    <td>调用子程序</td>
    <td>
        跳转到下一个命令指定的子程序地址。这个
        地址被记住在反向地址栈中（见<span class="but_b">В/О</span>）。
    </td>
</tr>
<tr>
    <th>54</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="op_k">НОП</span></td>
    <td>空操作符</td>
    <td></td>
</tr>
<tr>
    <th>55</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="but">1</span></td>
    <td>空操作符</td>
    <td></td>
</tr>
<tr>
    <th>56</th>
    <td class="tdcenter"><span class="but_k">К</span><span class="but">2</span></td>
    <td>空操作符</td>
    <td></td>
</tr>
<tr>
    <th>57</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">x&ne;0</span>
    </td>
    <td>如果不为零</td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X不等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>58</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">L2</span></td>
    <td>循环通过寄存器R2</td>
    <td></td>
</tr>
<tr>
    <th>59</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">x&ge;0</span>
    </td>
    <td>如果大于或等于零</td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X大于或等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>5A</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">L3</span></td>
    <td>循环通过寄存器R3</td>
    <td></td>
</tr>
<tr>
    <th>5B</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">L1</span></td>
    <td>循环通过寄存器R1</td>
    <td></td>
</tr>
<tr>
    <th>5C</th>
    <td class="tdcenter">
        <span class="but_f">F</span><span class="op_f">x&lt;0</span>
    </td>
    <td>如果小于零</td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X小于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>5D</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">L0</span></td>
    <td>循环通过寄存器R0</td>
    <td></td>
</tr>
<tr>
    <th>5E</th>
    <td class="tdcenter"><span class="but_f">F</span><span class="op_f">x=0</span></td>
    <td>如果等于零</td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>5F</th>
    <td class="tdcenter"></td>
    <td>挂起</td>
    <td>
        视觉上被感知为挂起。PMK不响应命令输入并且不显示任何东西。
        <br>
        通常无法输入这样的命令。
    </td>
</tr>
<tr>
    <th>60&hellip;6E</th>
    <td class="tdcenter">
        <span class="but_b">П&rarr;x</span><span class="but">R</span>
    </td>
    <td>从寄存器R0&hellip;Re提取到X</td>
    <td></td>
</tr>
<tr>
    <th>6F</th>
    <td class="tdcenter"></td>
    <td>从寄存器R0提取到X</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>70&hellip;7E</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">R</span>
    </td>
    <td>
        间接条件跳转如果不等于零，跳转地址在
        寄存器R0&hellip;Re
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X不等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>7F</th>
    <td></td>
    <td>
        间接条件跳转如果不等于零，跳转地址在
        寄存器R0
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X不等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
        <br>
        通常无法输入这样的命令。
    </td>
</tr>
<tr>
    <th>80&hellip;8E</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
    </td>
    <td>
        间接无条件跳转到寄存器
        R0&hellip;Re中的跳转地址
    </td>
    <td></td>
</tr>


<tr>
    <th>8F</th>
    <td></td>
    <td>间接无条件跳转到R0寄存器中的跳转地址</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>90&hellip;9E</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">R</span>
    </td>
    <td>
        如果大于或等于零，间接条件跳转到R0&hellip;Re寄存器中的跳转地址
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X大于或等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>9F</th>
    <td></td>
    <td>
        如果大于或等于零，间接条件跳转到R0寄存器中的跳转地址
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X大于或等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
        <br>
        通常无法输入这样的命令。
    </td>
</tr>
<tr>
    <th>A0&hellip;AE</th>
    <td class="tdupyter">
        <span class="but_k">К</span><span class="but_b">ПП</span><span class="but">R</span>
    </td>
    <td>
        根据R0&hellip;Re寄存器中的地址间接调用子程序
    </td>
    <td></td>
</tr>
<tr>
    <th>AF</th>
    <td></td>
    <td>根据R0寄存器中的地址间接调用子程序</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>B0&hellip;BE</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>
    </td>
    <td>
        根据R0&hellip;Re寄存器中的编号间接保存X到寄存器
    </td>
    <td></td>
</tr>
<tr>
    <th>BF</th>
    <td></td>
    <td>根据R0寄存器中的编号间接保存X到寄存器</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>C0&hellip;CE</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">R</span>
    </td>
    <td>
        如果小于零，间接条件跳转到R0&hellip;Re寄存器中的跳转地址
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X小于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>
<tr>
    <th>CF</th>
    <td></td>
    <td>
        如果小于零，间接条件跳转到R0寄存器中的跳转地址
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X小于零（在大多数语言中通常相反，条件满足时跳转到地址）。
        <br>
        通常无法输入这样的命令。
    </td>
</tr>
<tr>
    <th>D0&hellip;DE</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
    </td>
    <td>
        根据R0&hellip;Re寄存器中的编号间接从寄存器中提取X
    </td>
    <td></td>
</tr>
<tr>
    <th>DF</th>
    <td></td>
    <td>根据R0寄存器中的编号间接从寄置中提取X</td>
    <td>通常无法输入这样的命令。</td>
</tr>
<tr>
    <th>E0&hellip;EE</th>
    <td class="tdcenter">
        <span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
    </td>
    <td>
        如果等于零，间接条件跳转到R0&hellip;Re寄存器中的跳转地址
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
    </td>
</tr>

<tr>
    <th>EF</th>
    <td></td>
    <td>
        如果等于零，间接条件跳转到R0寄存器中的跳转地址
    </td>
    <td>
        跳过跳转地址，并执行其后面的命令，
        如果X等于零（在大多数语言中通常相反，条件满足时跳转到地址）。
        <br>
        通常无法输入这样的命令。
    </td>
</tr>
<tr>
    <th>F0&hellip;FF</th>
    <td></td>
    <td>空操作符</td>
    <td>通常无法输入这样的命令。</td>
</tr>
</table>

<p>
    一些带有数字F的命令也可以通过未记录的方式获得。
</p>
<p>
    在计算模式下执行一对命令<span class="but_b">В/О</span>&ensp;<span class="but_k">К</span><span class="but_b">ПП</span><span class="but">R</span>（R = 0&hellip;e）后，可以通过地址30&hellip;44获得F0&hellip;FE命令，这将把PMK转换为程序输入模式并插入带有数字F的代码。此时，在寄存器R0&hellip;R3中必须有一个以1或2结尾的数字（更确切地说，以便在间接寻址后以1或2结尾）。如果那里有其他数字（例如，像打开PMK后的零），那么对于R1&hellip;R3，将在地址30&hell式32插入F0&hellip;F2，而对于R0，这是获得3Г0ГГа的最快方式（并且不会进入程序输入模式）。
</p>
<p>
    如果在任何地址上连续5个命令FF（每隔一个）可以通过用一个以空格开始的数字“覆盖”返回栈，并在进入PRG模式之前按下<span class="but">БП</span>“地址”。然后从“地址”-11开始，每隔一个位置将放置命令FF。
    <br>
    首先，我们获得一个以初始空格开始的地址，例如数字F8，并将其保存在寄存器中，例如R7。同时，不要忘记在最后从RX中删除这样的数字！
    <br>
    <span class="but">8</span>&ensp;
    <span class="but">8</span>&ensp;
    <span class="but">8</span>&ensp;
    <span class="but">В&uarr;</span>&ensp;
    <span class="but">7</span>&ensp;
    <span class="but">7</span>&ensp;
    <span class="but_k">K</span><span class="op_k">&or;</span>&ensp;
    <span class="but_k">K</span><span class="op_k">{x}</span>&ensp;
    <span class="but">ВП</span>&ensp;
    <span class="but">2</span>&ensp;
    <span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
    <span class="but_cx">Cx</span>
    <br>
    现在，我们将根据这个“黑暗”地址通过R7插入子程序调用命令：
    <br>
    <span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span>&ensp;
    <span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
    <span class="but_k">К</span><span class="but_b">ПП</span><span class="but">7</span>&ensp;
    <span class="but_f">F</span><span class="op_f">АВТ</span>&ensp;
    <span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span>
    <br>
    然后按<span class="but_b">ПП</span>五次（以“覆盖”返回栈）
    <br>
    之后，我们选择我们需要FF命令的位置。假设我们想要从地址80开始。然后我们跳转到80+11=91<span class="but_b">БП</span><span class="but">91</span>和<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;<span class="but_f">F</span><span class="op_f">АВТ</span>
    <br>
    现在，地址80、82、84、86、88已经添加了FF命令。如果需要更多，例如还有地址81、83、85、87、89，那么只需再次填充返回栈<span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span>，5次<span class="but_b">ПП</span>，然后在<span class="but_b">БП</span><span class="but">92</span>和<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;<span class="but_f">F</span><span class="op_f">АВТ</span>之后，我们将得到我们想要的。
    <br>
    最后不要忘记清理返回栈（如В/О命令的注释所述）！
</p>
</details>

<hr>

<details id="div_glossary" open>
    <summary><h3>术语列表</h3></summary>
    <dl>
        <dt>ЕГГ0Г</dt>
        <dd>
            <div id="div_glos_err100">
                通常显示操作错误，特别是数字在范围1<sup>100</sup>&hellip;1<sup>199</sup>。
            </div>
        </dd>
        <dt>3Г0ГГ</dt>
        <dd>
            <div id="div_glos_err200">
                数字在范围1<sup>200</sup>&hellip;1<sup>299</sup>。
            </div>
        </dd>
        <dt>Еггогология</dt>
        <dd>
            <div id="div_glos_errors">
                研究PMK的未记录功能，主要是在超大数领域。参见
                <a href="https://ru.wikipedia.org/wiki/Еггогология" target="_blank">
                    https://ru.wikipedia.org/wiki/Еггогология
                </a>
            </div>
        </dd>
        <dt>符号数字</dt>
        <dd>
            <div id="div_glos_zero_digit">
                位于符号位置的数字。参见
                <a href="#div_zero_digit">
                    数字，其符号位置是一个数字。
                </a>
            </div>
        </dd>
        <dt>非规范化数字</dt>
        <dd>
            <div id="div_glos_unnormalize">
                显示前导零的数字。
            </div>
        </dd>
        <dt>规范化</dt>
        <dd>
            <div id="div_glos_normalization">
                规范化 - 输出没有前导零的数字。在十六进制数字转换的上下文中，也意味着转换为十进制数字，多余的十位数转移到高位。
            </div>
        </dd>
        <dt>PMK</dt>
        <dd>
            <div id="div_glos_calculator">
                可编程微计算器。
                在文章的上下文中 - MK-61。
            </div>
        </dd>
        <dt>空位</dt>
        <dd>
            <div id="div_glos_F">
                第一个数字由十六进制数字F表示的数字。这样的数字PMK不显示，即看起来像一个空的符号位置。
            </div>
        </dd>
        <dt>X2寄存器</dt>
        <dd>
            或屏幕寄存器 - 见
            <a href="#div_x2">神秘的X2寄存器</a>。
        </dd>
        <dt>超大数</dt>
        <dd>
            <div id="div_glos_super_num">
                其阶数超过PMK记录的数字范围，即阶数不在-99&hellip;99范围内，例如1<sup>120</sup>或4<sup>-180</sup>。
            </div>
        </dd>
        <dt>暗地址</dt>
        <dd>
            <div id="div_glos_shadow">
                十六进制地址，位于其上的PMK在程序输入模式下不显示操作代码（黑屏）。
            </div>
        </dd>
    </dl>
</details>

<details id="translation" open>
    <summary><h3>翻译说明</h3></summary>
<div align=center><a name=translation><span id=code>翻译说明</span></a></div>

<p>
版本: <span id=code>0.002</span>
</p>

<p>
时间: <span id=code>2024-09-02</span>
</p>

<p>
译者: <span id=code>FreeBlues</span>
</p>

<p>
QQ：<span id=code>642160780</span>
</p>

<p>
计算器爱好者QQ群: <span id=code>812224709/435067924</span>
</p>


<p>
特别说明：全文AI翻译，因为实在不懂俄语，若有不准确的地方请指出，谢谢！
</p>

<p>
<a href="https://xvadim.github.io/xbasoft/pmk/undocument_features.html">俄文未公开文档原文链接</a>
</p>



</details>

<footer>
    <address class="align_right">文档作者：Анваров С.Р.</address>
</footer>


 
</body>
</html>
